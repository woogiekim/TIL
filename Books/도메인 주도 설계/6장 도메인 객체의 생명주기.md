# 도메인 객체의 생명주기

- AGGREGATE는 소유권과 경계를 명확히 정의함으로써 모델을 엄격학 만들어 객체 간의 연관관계가 혼란스럽게 얽히지 않게 한다.
- 이 패턴은 생명주기상의 전 단계에 걸쳐 도메인 객체의 무결성을 유지하는 데 매우 중요하다.

## 살펴 볼 내용
- FACTORY를 이용해 복잡한 객체와 AGGREGATE을 생성하고 재구성함으로써 그것들의 내부 구조를 캡슐화 하는 것
- 생명주기의 중간과 마지막을 다루며, 거대한 관련 인프라스트럭처를 캡슐화 하면서 영속 객체를 찾아 조회하는 수단을 제공하는 REPOSITORY

## AGGREGATE
- 동일한 객체에 여러 클라이언트가 동시에 접근하는 시스템에서 매우 심각해진다.
- 여러 사용자가 시스템에서 다양한 객체를 참조하거나 갱신한다면 상호 의존 관계에 있는 객체가 동시에 변경되지 않게 해야 한다.
- 변경의 범위를 알맞게 한정하지 않는다면 심각한 결과가 초래될 것이다.


- 모델 내에서 복잡한 연관관계를 맺는 객체를 대상으로 변경의 일관성을 보장하기란 쉽지 않다.
- 그 까닭은 단지 개별 객체만이 아닌 서로 밀접한 관계에 있는 객체 집합에도 불변식이 적용돼야 하기 때문이다.


- 데이터베이스는 다양한 잠금 기법을 제공하며, 그와 같은 잠금 기법을 테스트하는 코드를 작성할 수도 있다.
- 그러나 이 같은 임시방편적인 해법은 모델에 집중하는 것을 방해하고, 곧 "일단 해보고 잘 되길 바라는" 상태로 되돌아갈것이다.
- 사실 이러한 문제의 균형 잡힌 해법을 찾으려면 도메인을 심층적으로 이해해야 하며,
- 특히 이 경우에는 특정 클래스 인스턴스 사이의 변화 빈도와 같은 사항까지 이해하고 있어야 한다.
- 경합이 높은 지점을 느슨하게 하고, 엄격한 불변식을 더욱 엄격하게 지켜지게 하는 모델을 찾을 필요가 있다.


- 먼저 우리는 모델 내의 참조에 대한 캡슐화르 추상화할 필요가 있다.
- AGGREGATE는 우리가 데이터 변경의 단위로 다루는 연관 객체의 묶음을 말한다.
- 각 AGGREGATE에는 루트(root)와 경계(boundary)가 있다.
- 경계는 AGGREGATE에 무엇이 포함되고 포함되지 않는지를 정의한다.
- 루트는 단 하나만 존재하며, AGGREGATE에 포함된 특정 ENTITY를 가리킨다.
- 경계 안의 객체는 서로 참조할 수 있지만, 경계 밖의 객체는 해당 AGGREGATE의 구성요소 가운데 루트만 참조할 수 있다.
- 루트 외의 ENTITY는 지역 식별성을 지니며, 지역 식별성은 AGGREGATE 내에서만 구분되면 된다.
- 해당 AGGREGATE의 경계 밖에 위치한 객체는 루트 ENTITY의 컨텍스트 말고는 AGGREGATE의 내부를 볼 수 없기 때문이다.


- 사람들은 데이터베이스에 조회해서 자동차를 찾은 다음 타이어를 일시적으로 참조할 것이다.
- 따라서 자동차는 타이어도 포함하는 경계를 지닌 AGGREGATE의 루트 ENTITY로 볼 수 있다.
- 반면, 엔진부에는 몸체에 일련번호가 새겨져 있으며 때때로 그와 같은 일련번호는 차량과는 무관하게 추적되기도 한다.
- 따라서 어떤 애플리케이션에서는 엔진이 자체적인 AGGREGATE의 루트일지도 모른다.


- 불변식은 데이터가 변경될 때마다 유지돼야 하는 일관성 규칙을 뜻하며,
- 여기엔 AGGREGATE를 구성하는 각 구성요소 간의 관계도 포함될 것이다.
- 여러 AGGREGATE에 걸쳐 존재하는 규칙이 언제나 최신 상태로 유지되는 것은 아니다.
- 이벤트 처리, 배치 처리, 혹은 다른 갱신 매커니즘을 토대로 특정 시간 내에 해결될 수 있다.


### 규칙

- 루트 ENTITY는 전역 식별성을 지니며 궁극적으로 불변식을 검사할 책임이 있다.
- 각 루트 ENTITY는 전역 식별성을 지닌다. 경계 안의 ENTITY의 지역 식별성을 지니며, 이러한 지역 식별성은 해당 AGGREGATE안에서만 유일하다.
- AGGREGATE의 경계 밖에서는 루트 ENTITY를 제외한 AGGREGATE 내부의 구성요소를 참조할 수 없다. 루트 ENTITY가 내부 ENTITY에 대한 참조를 다른 객체에 전달해 줄 수는 있지만
  그러한 객체는 전달 받은 참조를 일시적으로만 사용할 수 있고, 참조를 계속 보유하고 있을 수는 없다. 루트는 VALUE OBJECT의 복사본을 다른 객체에 전달해 줄수 있으며,
  복사본에서는 어떤 일이 일어나든 문제되지 않는다. 이것은 복사본이 단순한 VALUE에 불과하며 AGGREGATE와는 더는 연관관계를 맺지 않을 것이기 때문이다.
- 지금까지의 규칙을 바탕으로 결론을 내려보면 데이터베이스 질의를 이용하면 AGGREGATE의 루트만 직접적으로 획득할 수 있다. 다른 객체는 모두 AGGREGATE를 탐색해서 발견해야 한다.
- AGGREGATE 안의 객체는 다른 AGGREGATE의 루트만 참조할 수 있다.
- 삭제 연산은 AGGREGATE 경계 안의 모든 요소를 한 번에 제거해야 한다.
  (가비지 컬렉션을 이요하면 이렇게 하기가 쉬운데, 루트를 제외한 나머지 구성요소는 외부에서 그것을 참조하지 않을 경우 루트가 삭제되면 가비지 컬렉터가 자동으로 그것들을 모두 수집할 것이기 때문이다.)
- AGGREGATE 경계 안의 어떤 객체를 변경하더라도 전체 AGGREGATE의 불변식은 모두 지켜져야 한다.


- ENTITY와 VALUE OBJECT를 AGGREGATE로 모으고 각각에 대해 경계를 정의하라.
  - 한 ENTITY를 골라 AGGREGATE의 루트로 만들고 AGGREGATE 경계 내부의 객체에 대해서는 루트를 거쳐 접근할 수 있게 하라.


---

## AGGREGATE, FACTORY, REPOSITORY
-무결성을 유지하기 위해 필요한 도구 혹은 패턴

### 지역식별성
-외부에 노출하지 않고 에그리것 내부에서에서 루트를 통해서만 통용할 수 있음

### AGGREGATE 결정짓는 어려움
- 어디서 부터 어디까지 집합 할 것인가 결정짓는 것이 어렵다

- 제약조건 기준으로 모아야한다.
- 불변식이 적용되는 범위까지 모아야한다.
- 같은 라이프사이클을 가지는 엔티티끼리 모아야한다.

- 반번흔 조언
  - 되도록 AGGREGATE을 작게 만들어라.


## REPOSITORY
- 데애텨 다룸을 객체 탐색으로 할 수 있게
- DB 질의를 캡슐화
- 객체 탐색의 흐름을 끊어내고 어떤 시점에서 다시 ID 기반으로 탐색할 것인가 이것이 중요해짐
- CQRS
  - 리포팅성 쿼리 어떤식으로 해결할 것인가...?
  - 조회용 모델과 변경용 모델을 구분하자