# 의식적으로 지름길 사용하기

- 지름길을 방지하기 위해선 먼저 지름길 자체를 파악해야한다.
- 잠재적인 지름길 인식해야 한다.
- 소프트웨어는 쉽게 변하기 때문에 지름길을 선택했던 이유가 사라질 수 있다.
- 어떤 떄는 지름길이 가성비일 때도 있다.


## 왜 지름길은 깨진 창문 같을까?

### 깨진 창문 이론

- 번호판 없는 차 두대를 각각 다른 지역에 주차


- 브롱크스 근처에 한 대 주차
  - 24시간 안지나서 망가짐
- 팔로 알토 (브롱크스 보다 주거 환경 더 좋음) 근처에 한 대 주차
  - 안망가짐
- 팔로 알토 차에 일부로 창문을 깨뜨림
  - 짧은 시간에 망가짐

> 어떤 것이 멈춘것처럼 보이고, 망가져 보이고,
> 혹은 관리되지 않는다고 여겨지면 인간의 뇌는 이를 더 멈추고, 망가뜨리고,
> 해도 된다고 생각하게 된다.

- 품질이 떨어진 코드에서 작업할 때 더 낮은 품질의 코드를 추가하기 쉽다.
  - 품질이 높은 코드에서 작업할 때 더 높은 품질의 코드를 추가하기 쉬워지는가?
- 코딩 규칙을 많이 어긴 코드에서 작업할 때 또 다른 규칙을 어기기도 쉽다.
  - 코딩 규칙을 잘 지킨 코드에서 잘 작업할 때 규칙을 잘 지키기 쉬운가?
- 지름길을 많이 사용한 코드에서 작업할 때 또 다른 지름길을 추가하기도 쉽다.
  - 지름길을 사용안한 코드에서 작업할 때 지름길을 추가하기 쉽지 않은가?

## 깨끗한 상태로 시작할 책임

- 가능한 지름길은 지양해야한다.
- 깨진 창문을 막는 것이 개발자의 막대한 책임
- 때로는 지름길이 실용적일 때도 있다.
  - 별로 중요하지 않는 부분 (단순 게시판, 관리자 페이지 등)
  - 프로토타이핑 작업 중 혹은 경제적인 이유
  - 어쨌거나 기록이 중요하다.

## 유스케이스간 모델 공유하기

- SendMoneyUseCase 와 RevokeActivityUseCase 가 SendMoneyCommand 를 공유함으로써 결합됨
- SendMoneyCommand 클래스를 변경하면 SendMoneyUseCase 와 RevokeActivityUseCase 모두 변경이 된다는 이야기
- 이 말은 즉슨, 변경할 이유를 서로 공유하고 있다는 것이다. 그렇다는 것은 단일 책임 원칙을 위반한다.


- 두 유스케이스가 기능적으로 묶여 있고, 특정 요구사항을 공유하고 있기 때문이기도 하고
- 특정 세부사항을 변경했을 때 두 유스케이스 모두에게 영향을 주고 싶기 때문이다.
- 하지만, 두 유스케이스가 서로 영향 없이 독립적으로 진화해야하는 상황이 오면 유스케이스 간 모델 공유하기는 지름길이 된다.


- 비슷한 개념의 유스케이스를 여러개 만들면 이 유스케이스는 독립적이여야 하는가?
- 주기적으로 질문을 해야하고, 그 대답이 YES 가 되는 순간이 입출력 모델 분리 시점이다.


## 도메인 엔티티를 입출력 모델로 사용하기
 
### 무엇이 문제인가?

- Account 엔티티에 존재하지 않는 정보를 SendMoneyUseCase가 필요 
- SendMoneyUseCase가 필요한 정보는 Account 가 아니라 다른 도메인 혹은 바운디드 컨텍스트에 저장 되어야 함 
- 그러나, SendMoneyUseCase 가 Account 를 직접적으로 알고 있기 때문에 Account 를 변경 하고 싶어짐

### 위험해 지는 순간

- 유스케이스가 단순 작업이 아니라 복작한 도메인 로직 구현을 해야 함 
- 유스케이스 인터페이스에 대한 전용 입출력 모델을 만들어야 함 
- 유스케이스 변경이 도메인 엔티티까지 전파되는 것을 바라진 않기 때문

### 위험한 이유

- 간단했던 유스케이스가 시간이 지나면서 복잡해짐 → 복잡한 도메인 로직 괴물이 되어감

### 결론

- 간단한 유스케이스라서 도메인 엔티티를 입력으로 사용 
- 유스케이스가 복잡해짐에 따라 입력 모델의 변화 필요 → 독립적인 전용 입력 모델로 교체


## 인커밍 포트 건너뛰기

### 인커밍 포트 건너뛰기를 하면?

- 추상화 계층이 한 단계 줄기 때문에 복잡도가 줄어든다. 

### 인커밍 포트 건너뛰기의 단점

- 인커밍 포트는 애플리케이션 중심에 접근하는 진입점을 정의 
- 어떤 서비스의 어떤 메서드를 호출해야 하는 가? 
- 내부 동작에 대해서 더 잘 알아야 함 
- 아키텍처 강제가 가능하기 때문에 인커핑 포트를 유지하면 좋다 
  - 10장의 강제 옵션들을 활용 
  - 그런데 이 말은 강제 옵션을 적용 했을 때 이야기 
  - 강제가 강할 수록 자유도는 떨어질 것이고, 오히려 아키텍처를 변화할 수 없게 만드는 족쇄가 될 수도?

### 결론

- 애플리케이션 규모가 작거나 인커밍 어댑터가 하나밖에 없다? 
- 모든 흐름이 인커밍 포트 없이 파악 가능? 
- 인커핑 포트가 없는게 편함 
- 과연 계속 인커밍 어댑터가 하나밖에 없을 것이라고 확신할 수 있을까?


## 애플리케이션 서비스 건너뛰기

### 애플리케이션 서비스 건너뛰기 라는 것은?

- 아웃고잉 어댑터가 직접 인커밍 포트를 구현한다 
- 애플리케이션 서비스 건너뛰기를 하면? 
- 간단한 CRUD 유스케이스에서는 별다른 로직 없음 → 아웃고잉 어댑터에서 직접 구현이 정말 솔깃함 
- 작성하는 도메인 코드는 정말 적은데, 전달 용 코드는 너무 많아서 배보다 배꼽이 더 크게 느껴질 수 있음

### 애플리케이션 서비스 건너뛰기의 단점

- 인커밍 어댑터와 아웃고잉 어댑터 사이에 모델을 공유 → 변화에 민감해짐 
- 애플리케이션 코어에 유스케이스가 사라짐 → 요구사항 증가로 점점 복잡해짐 → 도메인 로직이 흩어져 버림

### 결론

- 단순 전달을 위한 보일러플레이트 코드 방지를 위해 애플리케이션 서비스 건너뛰기 결정 할 수도 있음 
- 복잡해지는 시점에 애플리케이션 서비스 만든다 라는 명확한 가이드라인 필요 
- 아키텍처 의사결정 레코드를 통해 잘 기록할수 있지 않을까?


## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 경제적인 관점에서 지름길이 합리적 일 수 있음
- 간단한 CRUD 유스케이스에 대해서는 지름길 유혹 느낄 수 있음 
- 단순 CRUD 를 벗어나는 기준과 시점이 언제인가? 
- 팀의 합의가 필요 → 합의를 통해 지름길을 유지보수 하기 좋은 아키텍처로 대체가능 
- 단순 CRUD 를 벗어나지 않는 유스케이스도 있음 
- 왜 특정 지름길을 선택했는지 기록 
- 우리 자신 혹은 미래의 팀원이 이 결정을 다시 평가 할 수 있게 하자
