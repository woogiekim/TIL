# 의존성 역전하기

- 1장에서는 계층형 아키텍처에 대한 불만 늘어놓았다면,
- 2장에서는 그에 대한 대안을 제시

## 단일 책임 원칙

### 일반적인 해석

> 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.

### 제안하는 해석

> 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.

- 컴포넌트 A의 경우 다른 여러 컴포넌트에 의존하고 있다. (직접적이든 간접적이든)
- 컴포넌트 E의 경우 의존하는 것이 전혀 없다.
- 컴포넌트 E를 변경할 유일한 이유는 새로운 요구사항에 의해 E의 기능을 바꿔야 할 때이다.
- 많은 코드는 단일 책임 원칙을 위반하기 때문에 시간이 갈수록 변경하기 어려워진다.

### 고민해볼법한 포인트

- 한 가지 일만 한다는 것은 function을 하나만 만들어야 한다는 말인가?
- 만들어야 할 객체가 너무 많아지게 될 것 같다.
- 그러면, 관리하기 힘들어지고 오히려 복잡해지는 것은 아닐까?

## 부수효과에 관한 이야기

### 부수효과란?

- 코드의 한 영역을 변경했더니 다른 영역에서 영향을 미친다.

### 이야기

- 코드의 한 영역 변경 → 다른 영역에서 부수효과 발생
- 철저하게 자동화된 테스트 추가 및 리팩터링 진행
- 클라이언트가 사용자 입장의 이상한 방식으로 동작하는 기능 구현요청
- 조금 더 사용자 친화적 + 적은 변경 + 구현하는 비용이 저렴한 방식을 제안
- 그러나, 핵심적인 특정 컴포넌트 변경 필요
- 클라이언트가 제안 거절
- [과거 경험] 해당 컴포넌트를 변경 → 다른 무언가가 망가짐 → 부수효과를 우려

## 의존성 역전 원칙

- 계층형 아키텍처의 계층 간 의존성 → 항상 아래 방향 가리킨다.
- 단일 책임 원칙을 고수준에서 적용 → 상위 계층이 하위계층보다 변경할 이유 많다

### 의존성 역전 원칙의 의미

- 코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.

### 의존성 역전은 어떻게 동작할까?

- 엔티티는 도메인 객체를 표현 → 도메인 코드는 이 엔티티들의 상태를 변경
- 엔티티를 도메인 계층으로 올린다.
- 그러나, 영속성에 있는 리포지토리가 도메인의 엔티티를 의존 → 두 계층 사이에 순환 의존성이 생긴다.
- DIP를 적용하자 서비스에 리포지토리 인터페이스 생성 → 영속성 계층에서 구현 → 결과적으로 의존성이 역전
- 도메인 코드와 역속성 코드 간의 의존성을 역전 시키자.
- 영속성 코드가 도메인 코드에 의존하고, 도메인 코드를 변경할 이유의 개수를 줄이자.

## 클린 아키텍처

- 로버트 C. 마틴이 클린 아키텍처라는 용어를 같은 이름의 책에서 정립
- 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 한다.
- 대신 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드를 향한다

### 클린 아키텍처는 어떤 모양인가?

- 가장 중요한 규칙은 계층 간의 모든 의존성이 안쪽으로 향해야 한다는 것
- 이 아키텍처의 코어는 유스케이스를 통해 접근하는 도메인 엔티티
- 유스케이스는 서비스에게 단일 책임을 갖게 하기 위해 더 세분화 시켜 1장에서 문제로 제기한 넓은 서비스 문제를 해결
- 도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알수없다 → 특정 기술에 특화된 코드 가질수 없고, 비즈니스 규칙에 집중할 수 있다.
- 각 계층간에 데이터를 주고받기 위한 객체 변환이 필요

## 육각형 아키텍처(헥사고날 아키텍처)

- 코어와 통신하기 위해서는 각 포트의 어댑터를 통해 입력, 출력을 할 수 있다.
- 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
- 도메인 코드가 영속성과 UI 에 특화된 문제로부터 결합을 제거
- 그로인해, 코드를 변경할 이유의 수를 줄일 수 있다.
- 변경할 이유가 적어질 수록 유지보수성은 적어진다.
- 각 계층의 문제에 딱 맞도록 자유롭게 모델링이 가능해진다.

### 고민해볼만한 포인트

- Spring Data JPA를 통해편리하게 사용하던 부분들에 대해 포기해야 할 부분들이 생길 것 같음.
- 과연, 그 이득이 버리면서까지 JPA가 아닌 다른 영속성 프레임워크로 변경될 수 있음을 고려해야할까?