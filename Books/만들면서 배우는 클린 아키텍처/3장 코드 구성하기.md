# 코드 구성하기

- 코드를 보는 것만으로도 어떤 아키텍처인지 파악할 수 있다면 좋지 않을까?

- 새 프로젝트에서 가장 먼저 제대로 만들려고 하는 것은 패키지 구조다.
- 프로젝트에서 계속 사용할 괜ㅊ낳아 보이는 구조를 잡는다. 그러고 나서 프로젝트가 진행될수록 점점 바빠지고 패키지 구조는 짜임새 없는 엉망진창 코드를 그럴싸하게 보이게 만드는 껍데기일 뿐이라는 점을 깨닫게 된다.
- 한 패키지에 있는 클래스들이 불러오지(import) 말아야 할 다른 패키지에 있는 클래스들을 불러오게 된다.


```shell
buckpal
|--- domain
|    |--- Account
|    |--- Activity
|    |--- AccountRepository
|    |--- AccountService
|--- persistence
|    |--- AccountService
|--- web
     |--- AccountController
```

- 의존성 역전 원칙을 적용해서 의존성이 domain 패키ㅣ에 있는 도메인 코드만을 향하도록 해뒀다.
- 그러나 적어도 세가지 이유로 이 패키지 구조는 최적의 구조가 아니다.


- 첫 번쨰, 애플리케이션의 기능 조각(functional slice)이나 특성(feature)을 구분 짓는 패키지 경계가 없다.
- 두 번째, 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다. AccountService와 AccountController가 어떤 유스케이스를 구현했는지 파악할 수 있겠는가?
- 세 번째, 패키지 구조를 통해서 우리가 목표로 하는 아키텍처를 파악할 수 없다.
  - 육각형 아키텍처 스타일을 따랐다고 추측할 수는 있고, 그렇기 때문에 웹 어댑터와 영속성 어댑터를 찾기 위해 web, persistance 패키지의 클래스들을 조사해볼 수 있다.
  - 하지만 어떤 기능이 웹 어댑터에서 호출되는지, 영속성 어댑터가 도메인 계층에 어떤 기능을 제공하는지 한눈에 알아볼 수 없다.


## 기능으로 구성하기

- 다음 접근법은 예제 코드를 기능으로 구성한 것

```shell
buckpal
|--- account
     |--- Account
     |--- Activity
     |--- AccountRepository
     |--- AccountService
```

- 가장 본직적인 변경은 계좌와 관련된 모드 코드를 최상위 account 패키지에 넣었따는 점이다. 계층 패키지들도 없앴다.
- 각 기능을 묶은 새로운 그룹은 `account`와 같은 레벨의 새로운 패키지로 들어가고, 패키지 외부에서 접근되면 안 되는 클래스들에 대한 pakcage-private 접근 수준을 이용해 패키지 간의 경계를 강화할 수 있다.
- 패키지 경계를 pakcage-private 접근 수준과 결합하면 각 기능 사이의 불필요한 의존성을 방지할 수 있다.
- 또한 `AccountService`의 책임을 좁히기 위해 SendMoneyService로 클래스명을 바꿨다.


- 그러나 기능에 의한 패키징 방식은 사실 계층에 의한 패키징 방식보다 아키텍처의 가시성을 훨씬 더 떨어뜨린다. 어댑터를 나타내는 패키지명이 없고, 인커밍 포트, 아웃고잉 포트를 확인할 수 없다.
- 심지어 도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 SendMoneyService가 AccountRepository 인터페이스만 알고 있고 구현체는 알 수 없도록 했음에도 불구하고, package-private 접근 수준을 이용해 도메인 코드가 실수로 영속성 코드에 의존하는 것을 막을 수 없다.


## 아키텍처적으로 표현력 있는 패키지 구조

- 헥사고날 아키텍처에서 구조적으로 핵심적인 요소는 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉 어댑터다.

```shell
buckpal
|--- account
     |--- adapter
     |    |--- in
     |    |    |--- web
     |    |         |--- AccountController
     |    |--- out
     |    |    |--- persistence
     |    |         |--- AccountPersistanceAdapter
     |    |         |--- SpringDataAccountRepository
     |--- domain
     |    |--- Account
     |    |--- Acitivity
     |--- application
          |--- SendMoneyService
          |--- port
               |--- in
               |    |--- SendMoneyUseCase
               |--- out
                    |--- LoadAccountPort
                    |--- UpdateAccountStatePort
```

- 만약 패키지 구조가 아키텍처를 반영할 수 없다면 시간이 지남에 따라 코드는 점점 목표하던 아키텍처로부터 멀어지게 될 것이다.


- 또한 이처럼 표현력 있는 패키지 구조는 아키텍처에 대한 적극적인 사고를 촉진한다. 많은 패키지가 생기고, 현재 작업 중인 코드를 어떤 패키지에 넣어야 할지 계속 생각해야 하기 떄문이다.


- 그런데 패키지가 아주 많다는 것은 모든 것을 public으로 만들어서 패키지 간의 접근을 허용해야 한다는 것을 의미하는 게 아닐까?

- 적어도 어댑터 패키지에 대해서는 그렇지 않다. 이 패키지에 들어 있는 모든 클래스들은 application 패키지 내에 있는 포트 인터페이스를 통하지 않고는 바깥에서 호출되지 않기 떄문에 pakcage-private 접근 수준으로 둬도 된다.
- 그러므로 애플리케이션 계층에서 어댑터 클래스를 향하는 우발적인 의존성은 있을 수 없다.


## 의존성 주입의 역할

- 포트 인터페이스를 구현한 실제 객체를 누가 애플리케이션 계층에 제공해야 할까?
- 포트를 애플리케이션 계층 안에서 수동으로 초기화하고 싶지는 않다. 애플리케이션 계층에 어댑터에 대한 의존성을 추가하고 싶지는 않기 때문이다.


- 이 부분에서 의존성 주입을 활용할수 있다. 모든 계층에 의존성을 가진 중립적인 컴포넌트를 하나 도입하는 것이다.
- 이 컴포넌트는 아키텍처를 구성하는 대부분의 클래스를 초기화하는 역할을 한다.


## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 코드에서 아키텍처의 특정 요소를 찾으려면 이제 아키텍처 다이어그램의 박스 이름을 따라 패키지 구조를 탐색하면 된다.
- 이로써 의사소통, 개발, 유지보수 모두가 조금 더 수월해진다.