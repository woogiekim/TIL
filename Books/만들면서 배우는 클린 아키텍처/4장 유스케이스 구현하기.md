# 유스케이스 구현하기

- 애플리케이션, 웹, 영속성 계층이 현재 아키텍처에서 아주 느슨하게 결합돼 있기 때문에 필요한 대로 도메인 코드를 자유롭게 모델링할 수 있다.

## 유스케이스 둘러보기

- 유스케이스가 실제로 무슨 일을 하는지 살펴보자

1. 입력을 받는다
2. 비즈니스 규칙을 검증한다
3. 모델 상태를 조작한다
4. 출력을 반환한다


- 그러나 유스케이스는 `비즈니스 규칙`을 검증할 책임이 있다. 그리고 도메인 엔티티와 이 책임을 공유한다.


## 입력 유효성 검증

- 호출하는 어댑터가 유스케이스에 입력을 전달하기 전에 입력 유효성을 검증하면 어떨까? 음, 과연 유스케이스에서 필요로 하는 것을 호출자(caller)가 모두 검증했다고 믿을 수 있을까?
- 또, 유스케이스는 하나 이상의 어댑터에서 호출될 텐데, 그러면 유효성 검증을 각 어댑터에서 전부 구현해야 한다. 그럼 그 과정에서 실수할 수도 있고, 유효성 검증을 해야 한다는 사실을 잊어버리게 될 수도 있다.


- 애플리케이션 계층에서 입력 유효성을 검증해야 하는 이유는, 그렇게 하지 않을 경우 애플리케이션 코어의 바깥쪽으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있기 떄문이다.


- `입력 모델(input model)`이 이문제를 다루도록 해보자.


## 생성자의 힘

- 빌더를 호출하는 코드에 새로운 필드를 추가하는 것을 잊고 만다.


- 컴파일러는 이처럼 유효하지 않은 상태의 불변 객체를 만들려는 시도에 대해서는 경고해주지 못한다.
- 물론 런타임에(단위 테스트에서라면 더할나위 없고) 유효성 검증 로직이 동작해서 누락된 파라미터에 대해 에러를 던지긴 하겠지만 말이다.


## 유스케이스마다 다른 입력 모델

- 각기 다른 유스케이스에 동일한 입력 모델을 사용하고 싶은 생각이 들 때가 있다.
- '계좌 등록하기'와 '계좌 정보 업데이트하기'라는 두 가지 유스케이스를 보자. 둘 모두 거의 똑같은 계좌 상세 정보가 필요하다.


- 차이점은 '계좌 정보 업데이트하기'유스케이스는 업데이트할 계좌를 특정하기 위해 계좌 ID 정보를 필요로 하고, '계좌 등록하기' 유스케이스는 계좌를 귀속시킬 소유자의 ID 정보를 필요로 한다는 것이다.
- 그래서 두 유스케이스에서 같은 입력 모델을 공유할 경우 '계좌 정보 업데이트하기'에서는 계좌 ID에, '계좌 등록하기'에서는 소유자 ID에 null 값을 허용해야 한다.


- 불변 커맨드 객체의 필드에 대해서 null을 유효한 상태로 받아들이는 것은 그 자체로 코드 냄새(code smell)다. 하지만 더 문제가 되는 부분은 이제 입력 유효성을 어떻게 검증하느냐다.
- 등록 유스케이스와 업데이트 유스케이스는 서로 다른 유효성 검증 로직이 필요하다. 아마도 유스케이스에 커스텀 유효성 검증 로직을 넣어야 할 테고,
- 이는 신성한 비즈니스 코드를 입력 유효성 검증과 관련된 관심로 오염시킨다.


## 비즈니스 규칙 검증하기

- "출금 계좌는 초과 출금되어서는 안 된다"라는 규칙을 보자.
- 정의에 따르면 이 규칙은 출금 계좌와 입금 계좌가 존재하느지 확인하기 위해 모델의 현재 상태에 접근해야 하기 떄문에 비즈니스 규칙이다.


- 반대로 "송금되는 금액은 0보다 커야 한다"라는 규칙은 모델에 접근하지 않고도 검증될 수 있다. 그러므로 입력 유효성 검증으로 구현할 수 있다.
- 송금액은 매우 중요하기 때문에 이 값을 검증하는 것은 어떤 경우라도 비즈니스 규칙으로 다뤄야 한다고 주장할 수도 있다.


- 그저 유효성 검증 로직이 현재 모델의 상태에 접근해야 하는지 여부만 확인하면 되기 때문이다.
- 이는 처음 규칙을 구현할 때뿐만 아니라 나중에 유지보수할 때 그것이 어디에 있는지 찾는데도 도움이 된다.


- 그러면 비즈니스 규칙 검증은 어떻게 구현할까?


- 가장 좋은 방법은 앞에서 "출금 계좌는 초과 인출되어서는 안 된다" 규칙에서처럼 비즈니스 규칙을 도메인 엔티티 안에 넣는 것이다.
- 이렇게 하면 이 규칙을 지켜야 하는 비즈니스 로직 바로 옆에 규칙이 위치하기 떄문에 위치를 정하는 것도 쉽고 추론하기도 쉽다.


## 풍부한 도메인 모델 vs. 빈약한 도메인 모델

- 유스케이스는 도메인 모델의 진입점으로 동작한다. 이어서 유스케이스는 사용자의 의도만을 표현하면서 이 의도를 실제 작업을 수행하는 체계화된 도메인 엔티티 메소드 호출로 반환한다.
- 많은 비즈니스 규칙이 유스케이스 구현체 대신 엔티티에 위치하게 된다.


- '송금하기' 유스케이스 서비스는 출금 계좌와 입금 계좌 엔티티를 로드하고, `withdraw()`, `deposit()` 메소드를 호출한 후, 결과를 다시 데이터베이스로 보낸다.
- 사실 이 유스케이스에서는 초과 출금을 방지하기 위해 입금 계좌와 출금 계좌에서 다른 어떤 돈도 동시에 이체되지 않도록 보장해야 하지만, 단순화를 위해 이 비즈니스 규칙은 생략했다.


- '빈약한'도메인 모델에서는 엔티티 자체가 굉장히 얇다.
- 이 말인 즉슨, 도메인 로직이 유스케이스 클래스에 구현돼 있다는 것이다. 비즈니스 규칙을 검증하고, 엔티티의 상태를 바꾸고, 데이터베이스 저장을 담당하는 아웃고잉 포트에 엔티티를 전달할 책임 역시 유스케이스 클래스에 있다.
- '풍부함'이 엔티티 대신 유스케이스에 존재하는 것이다.


## 유스케이스마다 다른 출력 모델

- 업데이트된 Account를 통쨰로 반환하고 싶을 수도 있다. 아마도 호출자가 계좌의ㅏ 새로운 잔액에 관심이 있을 지도 모른다.
- 그러나 '송금하기' 유스케이스에서 정말로 이 데이터를 반환해야 할까? 호출자가 정말로 이 값을 필요로 할까? 만약 그렇다면 다른 호출자도 사용할 수 있도록 해당 데이터에 접근할 전용 유스케이스를 만들어야 하지 않을까?


- 이러한 질문에 정답은 없다. 그러나 유스케이스를 가능한 한 구체적으로 유지하기 위해서는 계속 질문해야 한다. 만약 의심스럽다면 가능한 한 적게 반환하자.


- 유스케이스들 간에 같은 출력 모델을 공유하게 되면 유스케이스들도 강하게 결합된다.


## 읽기 전용 유스케이스는 어떨까?

- 앞에서 모델의 상태를 변경하는 유스케이스를 어떻게 구현할지 논의했다. 그렇다면 읽기 전용 유스케이스는 어떻게 구현할까?


- 읽기 전용 작업을 유스케이스라고 언급하는 것은 조금 이상하다. 물론 UI단에서는 '계좌 잔고 보여주기'라고 부를 수 있는 특정 유스케이스를 구현하기 위해 요청한 데이터가 필요할 수도 있다.
- 만약 전체 프로젝트의 맥락에서 이러한 작업이 유스케이스로 분류된다면 어떻게든 다른 유스케이스와 비슷한 방식으로 구현해야 한다.
- 하지만 애플리케이션 코어의 관점에서 이 작업은 간단한 데이터 쿼리다.


- 읽기 전용 쿼리는 쓰기가 가능한 유스케이스(또는 '커맨드')와 코드 상에서 명확하게 구분된다.
- 이런 방식은 CQS(Command-Query Separation)나 CQRS(Command-Query Responsibility Segregation)같은 개념과 아주 잘 맞는다.


## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 이 책의 아키텍처에서는 도메인 로직을 우리가 원하는 대로 구현할 수 있도록 허용하지만,
- 입출력 모델을 독립적으로 모델링한다면 원치 않는 부수효과를 피할 수 있다.


- 물론 유스케이스 간에 모델을 공유하는 것보다는 더 많은 작업이 필요하다.
- 각 유스케이스마다 별도의 모델을 만들어야 하고, 이 모델과 엔티티를 매핑해야 한다.


- 그러나 유스케이스별로 모델을 만들면 유스케이스를 명확하게 이해할 수 있고, 장기적으로 유지보수하기도 더 쉽다.
- 또한 여러 명의 개발자가 다른 사람이 작업 중인 유스케이스를 건드리지 않은 채로 여러 개의 유스케이스를 동시에 작업할 수 있다.


- 꼼꼼한 입력 유효성 검증, 유스케이스별 입출력 모델은 지속 가능한 코드를 만드는 데 큰 도움이 된다.