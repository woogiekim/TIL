# 웹 어댑터 구현하기

## 의존성 역전

- 웹 어댑터는 '주도하는' 혹은 '인커밍' 어댑터다. 외부로부터 요청을 받아 애플리케이션 코드어를 호출하고 무슨 일을 해야 할지 알려준다.
- 제어 흐름이 왼쪽에서 오른쪽으로 흐르기 때문에 웹 어댑터가 유스케이스를 직접 호출할 수 있다.


- 그럼 왜 어댑터와 유스케이스 사이에 또 다른 간접 계층을 넣어야 할까?
- 애플리케이션 코어가 외부 세계와 통신할 수 있는 곳에 대한 명세가 포트이기 때문이다.
- 포트를 적절한 곳에 위치시키면 외부와 어떤 통신이 일어나고 있는지 정확히 알 수 있고,
- 이는 레거시 코드를 다루는 유지보수 엔지니어에게는 무척 소중한 정보다.


- 엄밀히 말하자면 이 포트는 아웃고잉 포트이기 때문에 이제 웹 어댑터는 인커밍 어댑터인 동시에 아웃고잉 어댑터가 된다.
- 하지만 한 어댑터가 동시에 두 가지 역할을 하지 못할 이유는 없다.


- 이번 장의 나머지 부분에서는 웹 어댑터가 일반적인 인커밍 어댑터 역할만 한다고 가정하겠다.


## 웹 어댑터의 책임

- 웹 어댑터는 실제로 어떤 일을 할까?
- 웹 어댑터의 책임은 어디서부터 어디까지일까?


- 웹 어댑터는 일반적으로 다음과 같은 일을 한다.

1. HTTP 요청을 자바 객체로 매핑
2. 권한 검사
3. 입려 유효성 검증
4. 입력을 유스케이스의 입력 모델로 매핑
5. 유스케이스 호출
6. 유스케스이스의 출력을 HTTP로 매핑
7. HTTP 응답을 반환


- 우선 웹 어댑터는 URL, 경로, HTTP 메소드, 콘텐츠 타입과 같이 특정 기준을 만족하는 HTTP 요청을 수신해야 한다.
- 그러고 나서 HTTP 요청의 파라미터와 콘텐츨르 객체로 역직렬화해야 한다.


- 유스케이스의 입력 모델과는 구조나 의미가 완전히 다를 수 있으므로 또 다른 유효성 검증을 수행해야 한다.
- 유스케이스 입력 모델에서 했던 유효성 검증을 똑같이 웹 어댑터에서도 구현해야 하는 것은 아니다.
- 웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 반환할 수 있다는 것을 검증해야 한다.
- 이 변환을 방해하는 모든 것이 유효성 검증 에러다.


- 웹 어댑터의 어깨를 짓누를 정도로 책임이 만힉는 하다. 하지만 이 책임들은 애플리케이션 계층으로 침투해서는 안된다.
- 우리가 바깥 계층에서 HTTP를 다루고 있다는 것을 애플리케이션 코어가 알게 되면 HTTP를 사용하지 않는 또 다른 인커밍 어댑터의 요청에 대해 동일한 도메인 로직을 수행할 수 있는 선택지를 잃게 된다.
- 좋은 아키텍처에서는 선택의 여지를 남겨둔다.


## 컨트롤러 나누기

- 그럼 컨트롤러를 몇 개 만들어야 할까? 너무 적은 것보다는 너무 많은 게 낫다.
- 각 컨트롤러가 가능한 한 좁고 다른 컨트롤러와 가능한 한 적게 공유하는 웹 어댑터 조각을 구현해야 한다.
- 자주 사용되는 방식은 AccountController를 하나 만들어서 계좌와 관련된 모든 요청을 받는 것이다.


- 앞의 예제 코드에서 많은 연산들이 AccountResource 모델 클래스를 공유한다. AccountResource가 모든 연산에서 필요한 모든 데이터를 담고 있는 큰 통인 것이다.
- 아마 AccountResource에는 id 필드가 있을 것이다.
- 그렇지만 이 id는 create 연산에서는 필요없기 때문에 도움이 되기보다 헷갈릴 수 있다.
- 그래서 각 연산에 대해 가급적이면 별도의 패키지 안에 별도의 컨트롤러를 만드는 방식을 선호한다. 또한 가급적 메소드와 클래스명은 유스케이스를 최대한 반영해서 지어야 한다.


## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 애플리케이션의 웹 어댑터를 구현할 때는 HTTP 요청을 애플리케이션의 유스케이스에 대한 메소드 호출로 변환하고 결과를 다시 HTTP로 변환하고 어떤 도메인 로직도 수행하지 않는 어댑터를 만들고 있다는 점을 염두에 둬야 한다.
- 반면 애플리케이션 계층은 HTTP에 대한 상세 정보를 노출시키지 않도록 HTTP와 관련된 작업을 해서는 안 된다. 이렇게 하면 필요할 경우 웹 어댑터를 다른 어댑터로 쉽게 교체할 수 있다.