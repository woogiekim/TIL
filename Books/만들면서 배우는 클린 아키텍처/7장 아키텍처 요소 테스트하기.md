# 아키텍처 요소 테스트하기

- 기본 전제는 만드는 비용이 적고, 유지보수하기 쉽고, 빨리 실행되고, 안정적인 작은 크기의 테스트들에 비해 높은 커버리지를 유지해야 한다는 것이다.


- 여러 개의 단위와 단위를 넘는 경계, 아키텍처 경계, 시스템 경계를 결합하는 테스트는 만드는 비용이 더 비싸지고, 실행이 더 느려지며 깨지기 더 쉬워진다.
- 테스트 피라미드는 테스트가 비싸질수록 테스트의 커버리지 목표는 낮게 잡아야 한다는 것을 보여준다.
- 그렇지 않으면 새로운 기능을 만드는 것보다 테스트를 만든느데 시가능 더 쓰게 되기 때문이다.


- '단위 테스트', '통합 테스트', '시스템 테스트'의 정의는 매락에 따라 다르다는 것을 알아두자.
- 프로젝트마다 다른 의미를 가질 수 있다는 뜻이다.

## 테스트 종류

### 단위 테스트

- 단위테스트는 피라미드의 토대에 해당한다. 일반적으로 하나의 클래스를 인스턴스화하고 해당 클래스의 인터페이스를 통해 기능들을 테스트한다.


### 통합 테스트

- 이 테스트는 연결된 여러 유닛으 인스턴스화하고 시작점이 되는 클래스의 인터페이스로 데이터를 보낸 후 유닛들의 네트워크가 기대한대로 잘 동작하는지 검증한다.

### 시스템 테스트

- 애플리케이션을 구성하는 모든 객체 네트워크를 가동시켜 특정 유스케이스가 전 계층에서 잘 동작하는지 검증한다.


#### 애플리케이션의 UI를 포함하는 엔드투엔드(end-to-end) 테스트층이 있을 수 있다.


## 단위 테스트로 도메인 엔티티 테스트하기

```java
class AccountTest {
    @Test
    void withdrawalSucceeds() {
        AccountId accountId = new AccountId(1L);
        Account account = defaultAccount()
                .withAccountId(accountId)
                .withBaselineBalance(Money.of(55L))
                .withActivityWindow(new ActivityWindow(
                        defaultActivity()
                                .withTargetAccount(accountId)
                                .withMoney(Money.of(99L)).build(),
                        defaultActivity()
                                .withTargetAccount(accountId)
                                .withMoney(Money.of(1L)).build()))
                .build();
        
        boolean success = account.withdraw(Money.of(555L), new AccountId(99L));
        
        assertThat(success).isTrue();
        assertThat(account.getActivityWindow().getActivities()).hasSize(3);
        assertThat(account.calculateBalance()).isEqualTo(Money.of(1000L));
    }
}
```

- 특정 상태의 Account를 인스턴스화하고 withdraw() 메서드를 호출해서 출금을 성공했는지 검증하고,
- Account 객체의 상태에 대해 기대되는 부수효과들이 잘 일어났는지 확인하는 단순한 단위 테스트
- 이 테스트는 만들고 이해하는 것도 쉬운 편이고, 아주 빠르게 실행된다.
- 테스트가 이보다 간단할 수는 없다. 이런 식의 단위 테스트가 도메인 엔티티에 녹아 있는 비즈니스 규칙을 검증하기에 가장 적절한 방법이다.
- 도메인 엔티티의 행동은 다른 클래스에 거의 의존하지 않기 때문에 다른 종류의 테스트는 필요하지 않다.


## 단위 테스트로 유스케이스 테스트하기

- 테스트 중인 유스케이스 서비스는 상태가 없기(stateless) 때문에 `then` 섹션에서 특정 상태를 검증할 수 없다.
- 대신 테스트는 서비스가 (모킹된) 의존 대상의 특정 메서드와 상호작용했는지 여부를 검증한다.
- 이는 테스트 코드의 행동 변경뿐만 아니라 코드의 구조 변경에도 취약해진다는 의미가 된다.
- 자연스럽게 코드가 리팩터링되면 테스트도 변경 될 확률이 높아진다.


- 그렇기 때문에, 테스트에서 어떤 상호작용을 검증하고 싶은지 신중하게 생각해야 한다.
- 앞의 예제처럼 모든 동작을 검증하는 대신 중요한 핵심만 골라 집중해서 테스트하는 것이 좋다.
- 만약 모든 동작을 검증하려고 하면 클래스가 조금이라도 바뀔 때마다 테스트를 변경해야 한다.
- 이는 테스트의 가치를 떨어뜨리는 일이다.

## 통합 테스트로 웹 어댑터 테스트하기

- 웹 어댑터의 책임 대부분은 이 테스트로 커버된다.


- `MockMvc` 객체를 이용해 모킹했기 때문에 실제로 HTTP 프로토콜을 통해 테스트한 것은 아니다.
- 프레임워크가 HTTP 프로토콜에 맞게 모든 것을 적절히 잘 변환한다고 믿는 것이다(프레임워크를 테스트할 필요는 없으니 말이다).
- 만약 `SendMoneyCommand` 객체를 4장에서처럼 자체 검증 커맨드로 만들었따면 이 매핑이 유스케이스에 구문적으로 유효한 입력을 생성했는지도 확인할 것이다.
- 유스케이스가 실제로 호출했는지도 검증했고, HTTP 응답이 기대한 상태를 변환했는지도 검증했다.

- `@WebMvcTest` 애너테이션은 스프링이 특정 요청 경로, 자바와 JSON 간의 매핑, HTTP 입력 검증 등에 필요한 전체 객체 네트워크를 인스턴스화하도록 만든다.
- 그리고 테스트에서는 웹 컨트롤러가 이 네트워크의 일부로서 잘 동작하는지 검증한다.

- 웹 컨트롤러를 평범한 단위 테스트로 테스트하면 모든 매핑, 유효성 검증, HTTP 항목에 대한 커버리지가 낮아지고,
- 프레임워크를 구성하는 이런 요소들이 프로덕션 환경에서 정상적으로 작동할지 확신할 수 없게 된다.