# 아키텍처 요소 테스트하기

- 기본 전제는 만드는 비용이 적고, 유지보수하기 쉽고, 빨리 실행되고, 안정적인 작은 크기의 테스트들에 비해 높은 커버리지를 유지해야 한다는 것이다.


- 여러 개의 단위와 단위를 넘는 경계, 아키텍처 경계, 시스템 경계를 결합하는 테스트는 만드는 비용이 더 비싸지고, 실행이 더 느려지며 깨지기 더 쉬워진다.
- 테스트 피라미드는 테스트가 비싸질수록 테스트의 커버리지 목표는 낮게 잡아야 한다는 것을 보여준다.
- 그렇지 않으면 새로운 기능을 만드는 것보다 테스트를 만든느데 시가능 더 쓰게 되기 때문이다.


- '단위 테스트', '통합 테스트', '시스템 테스트'의 정의는 매락에 따라 다르다는 것을 알아두자.
- 프로젝트마다 다른 의미를 가질 수 있다는 뜻이다.

## 테스트 종류

### 단위 테스트

- 단위테스트는 피라미드의 토대에 해당한다. 일반적으로 하나의 클래스를 인스턴스화하고 해당 클래스의 인터페이스를 통해 기능들을 테스트한다.


### 통합 테스트

- 이 테스트는 연결된 여러 유닛으 인스턴스화하고 시작점이 되는 클래스의 인터페이스로 데이터를 보낸 후 유닛들의 네트워크가 기대한대로 잘 동작하는지 검증한다.

### 시스템 테스트

- 애플리케이션을 구성하는 모든 객체 네트워크를 가동시켜 특정 유스케이스가 전 계층에서 잘 동작하는지 검증한다.


#### 애플리케이션의 UI를 포함하는 엔드투엔드(end-to-end) 테스트층이 있을 수 있다.


## 단위 테스트로 도메인 엔티티 테스트하기

```java
class AccountTest {
    @Test
    void withdrawalSucceeds() {
        AccountId accountId = new AccountId(1L);
        Account account = defaultAccount()
                .withAccountId(accountId)
                .withBaselineBalance(Money.of(55L))
                .withActivityWindow(new ActivityWindow(
                        defaultActivity()
                                .withTargetAccount(accountId)
                                .withMoney(Money.of(99L)).build(),
                        defaultActivity()
                                .withTargetAccount(accountId)
                                .withMoney(Money.of(1L)).build()))
                .build();
        
        boolean success = account.withdraw(Money.of(555L), new AccountId(99L));
        
        assertThat(success).isTrue();
        assertThat(account.getActivityWindow().getActivities()).hasSize(3);
        assertThat(account.calculateBalance()).isEqualTo(Money.of(1000L));
    }
}
```

- 특정 상태의 Account를 인스턴스화하고 withdraw() 메서드를 호출해서 출금을 성공했는지 검증하고,
- Account 객체의 상태에 대해 기대되는 부수효과들이 잘 일어났는지 확인하는 단순한 단위 테스트
- 이 테스트는 만들고 이해하는 것도 쉬운 편이고, 아주 빠르게 실행된다.
- 테스트가 이보다 간단할 수는 없다. 이런 식의 단위 테스트가 도메인 엔티티에 녹아 있는 비즈니스 규칙을 검증하기에 가장 적절한 방법이다.
- 도메인 엔티티의 행동은 다른 클래스에 거의 의존하지 않기 때문에 다른 종류의 테스트는 필요하지 않다.


## 단위 테스트로 유스케이스 테스트하기

- 테스트 중인 유스케이스 서비스는 상태가 없기(stateless) 때문에 `then` 섹션에서 특정 상태를 검증할 수 없다.
- 대신 테스트는 서비스가 (모킹된) 의존 대상의 특정 메서드와 상호작용했는지 여부를 검증한다.
- 이는 테스트 코드의 행동 변경뿐만 아니라 코드의 구조 변경에도 취약해진다는 의미가 된다.
- 자연스럽게 코드가 리팩터링되면 테스트도 변경 될 확률이 높아진다.


- 그렇기 때문에, 테스트에서 어떤 상호작용을 검증하고 싶은지 신중하게 생각해야 한다.
- 앞의 예제처럼 모든 동작을 검증하는 대신 중요한 핵심만 골라 집중해서 테스트하는 것이 좋다.
- 만약 모든 동작을 검증하려고 하면 클래스가 조금이라도 바뀔 때마다 테스트를 변경해야 한다.
- 이는 테스트의 가치를 떨어뜨리는 일이다.

## 통합 테스트로 웹 어댑터 테스트하기

- 웹 어댑터의 책임 대부분은 이 테스트로 커버된다.


- `MockMvc` 객체를 이용해 모킹했기 때문에 실제로 HTTP 프로토콜을 통해 테스트한 것은 아니다.
- 프레임워크가 HTTP 프로토콜에 맞게 모든 것을 적절히 잘 변환한다고 믿는 것이다(프레임워크를 테스트할 필요는 없으니 말이다).
- 만약 `SendMoneyCommand` 객체를 4장에서처럼 자체 검증 커맨드로 만들었따면 이 매핑이 유스케이스에 구문적으로 유효한 입력을 생성했는지도 확인할 것이다.
- 유스케이스가 실제로 호출했는지도 검증했고, HTTP 응답이 기대한 상태를 변환했는지도 검증했다.

- `@WebMvcTest` 애너테이션은 스프링이 특정 요청 경로, 자바와 JSON 간의 매핑, HTTP 입력 검증 등에 필요한 전체 객체 네트워크를 인스턴스화하도록 만든다.
- 그리고 테스트에서는 웹 컨트롤러가 이 네트워크의 일부로서 잘 동작하는지 검증한다.

- 웹 컨트롤러를 평범한 단위 테스트로 테스트하면 모든 매핑, 유효성 검증, HTTP 항목에 대한 커버리지가 낮아지고,
- 프레임워크를 구성하는 이런 요소들이 프로덕션 환경에서 정상적으로 작동할지 확신할 수 없게 된다.

## 통합 테스트로 영속성 어댑터 테스트하기

- 비슷한 이유로 영속성 어댑터의 테스트에는 단위 테스트보다는 통합 테스트를 적용하는 것이 합리적이다.
- 단순히 어댑터의 로직만 검증하고 싶은 게 아니라 데이터베이스 매핑도 검증하고 싶기 때문이다.

- @DataJpaTest 애너테이션으로 스프링 데이터 리포지토리들을 포함해서 데이터베이스 접근에 필요한 객체 네트워크를 인스턴스화해야 한다고 스프링에 알려준다.
- @Import 애너테이션을 추가해서 특정 객체가 이 네트워크에 추가됐다는 것을 명확하게 표현할 수 있다.
- 이 객체들은 테스트 상에서 어댑터가 도메인 객체를 데이터베이스 객체로 매핑하는 등의 작업에 필요하다.


- loadAccount() 메서드에 대한 테스트에서는 SQL 스트립트를 이용해 데이터베이스를 특정 상태로 만든다.
- 어댑터 API를 이용해 계좌를 가져온 후 SQL 스트립트에서 설정한 상태값을 가지고 있는지 검증한다.

## 시스템 테스트로 주요 경로 테스트하기

- 피라미드의 최상단에 있는 시스템 테스트는 전체 애플리케이션을 띄우고 API를 통해 요청을 보내고, 모든 계층이 조화롭게 잘 동작하는지 검증한다.

- 시스템 테스트라고 하더라도 언제나 서드파티 시스템을 실행해서 테스트할 수 있는 것은 아니기 때문에 결국 모킹을 해야 할 때도 있다.
- 육각형 아키텍처는 이러한 경우 몇 개의 출력 포트 인터페이스만 모킹하면 되기 때문에 아주 쉽게 이 문제를 해결할 수 있다.


- 이전 절에서 이야기한 바와 같이 단위 테스트와 통합 테스트를 만들었다면 시스템 테스트는 앞서 커버한 코드와 겹치는 부분이 많을 것이다.
- 일반적으로 시스템 테스트는 단위 테스트와 통합 테스트가 발견하는 버그와는 또 다른 종류의 버그를 발견할 수 있게 해준다.
- 단위 테스트나 통합 테스트만으로는 알아차리지 못했을 계층 간 매핑 버그 같은 것들 말이다.


- 시스템 테스트는 여러 개의 유스케이스를 결합해서 시나리오를 만들 때 더 빛이 난다.
- 시스템 테스트를 통해 중요한 시나리오들이 커버된다면 최신 변경사항들이 애플리케이션을 망가뜨리지 않았음을 가정 할 수 있고,
- 배포될 준비가 됐다는 확신을 가질 수 있다.


## 얼마만큼의 테스트가 충분할까?

- 라인 커버리지는 테스트 성공을 측정하는 데 있어서는 잘못된 지표다.
- 코드의 중요한 부분이 전혀 커버되지 않을 수 있기 때문에 100%르 제외한 어떤 목표도 완전히 무의미하다.
- 그리고 심지어 100%라 하더라도 버그가 잘 잡혔는지 확신할 수 없다.


- 얼마나 마음 편하게 소프트웨어를 배포할 수 있느냐를 테스트의 성공 기준으로 삼으면 된다고 생각한다.
- 테스트를 실행한 후에 소프트웨어를 배포해도 될 만큼 테스트를 신뢰한다면 그것으로 된 것이다. 더 자주 배포할수록 테스트를 더 신뢰할 수 있다.


- 처음 몇 번의 배포에는 미음의 도약이 필요하다. 그렇지만 프로덕션의 버그를 수정하고 이로부터 배우는 것을 우선순위로 삼으면 제대로 가고 있는 것이다.


- 새로운 필드를 추가할 때마다 테스트를 고치는 데 한시간을 써야 한다면 뭔가 잘못된 것이다.
- 아마도 테스트가 코드의 구조적 변경에 너무 취약할 것이므로 어떻게 개선할지 살펴봐야 한다.
- 리팩터링할 때마다 테스트 코드도 변경해야 한다면 테스트는 테스트로서의 가치를 잃는다.