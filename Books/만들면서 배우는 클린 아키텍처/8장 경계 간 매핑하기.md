# 08 경계 간 매핑하기

# 지금까지

- 웹, 애플리케이션, 도메인 영속성 계층은 무엇인가?
- 유스케이스 하나를 구현하기 위해 각 계층이 하는 역할은?

---

# 각 계층 모델 매핑

## 매핑에 찬성하는 개발자

- 두 계층 간 매핑 안함 → 두 계층이 강하게 결합

## 매핑에 반대하는 개발자

- 두 계층 간 매핑 함 → 보일러플레이트 코드 많이 만들게 됨 → 유스케이스는 단순 CRUD만 수행 → 계층 간의 매핑 과함

## 보일러플레이트 코드란?

- 최소한의 변경으로 여러곳에서 재사용 되며, 비슷한 형태를 가지고 있는 코드
- 매핑에 사용하는 객체는 그 형태가 비슷할 것이고 약간의 필드 수정만 해서 여러곳에서 재사용 됨

---

# ‘매핑하지 않기’ 전략

- 컨트롤러, 유스케이스, 유스케이스 구현체 모두 Account 클래스에 접근 해야 함
- 각 포트에 해당하는 인터페이스가 도메인을 모델을 의존하면 매핑 객체 필요 없음.
- 비단 인커밍 뿐만 아니라 영속성 계층도 마찬가지

## 요구사항 변화

- 계좌 이름이랑 별칭이랑 합쳐서 보여주세요.
- 응답에 대한 변경이 전체 계층에 영향을 줌

## ‘매핑하지 않기’ 전략 쓰지 말기?

- 꼭 그런 것은 아니다
- 지저분하게 느껴질 수는 있지만 딱 들어맞을 때가 있다.
- 같은 필드를 가진 웹 모델을 도메인 모델로
- 같은 필드를 가진 도메인 모델을 영속성 모델로 매핑 할 필요 있을까?
- 도메인 모델에 추가한 JSON이나 ORM 애너테이션이 방해가 될까?
- 영속성 계층 계층의 뭔가가 바뀌었을 때 도메인 모델의 애너테이션 한 두개 바꿔야 하는게 크게 상관 있을까?

> 모든 계층이 정확히 같은 구조, 정확히 같은 정보를 필요로 한다 → ‘매핑하지 않기 전략’은 완벽한 선택지
어떤 매핑 전략을 선택했더라도 나중에 언제든 바꿀 수 있다.
>

## 우리는 이 전략을 어디서 쓰고 있나?

- 눌러 주세요!

  도메인 모델에서 쓰고 있지 않을까?
  도메인 모델과 영속성 모델을 따로 구분하지않고 하나로 사용하고 있기 때문에
  우리는 애플리케이션 계층과 영속성 계층의 매핑 전략을 ‘매핑하지 않기’ 전략으로 쓰고 있지 않을까?


---

# ‘양방향’ 매핑 전략

- 웹 모델을 도메인 모델로 매핑, 도메인 객체를 다시 웹 모델로 매핑
- 영속성 모델 또한 마찬가지
- 두 계층이 모두 양방향으로 매핑하기 때문에  ‘양방향’ 매핑이라고 함

## 장점

- 전용 모델 변경 → 다른 계층 모델 영향 X
- 물론, 내용 자체가 변경되는 것은 예외
- 각 계층별로 간섭없이 필요로 하는 구조로 변경 가능
- 오염되지 않는 깨끗한 도메인 모델 유지 → 단일 책임 원칙 만족

## 단점

- 너무 많은 보일러플레이트 코드가 생김
- 매핑 프레임워크를 사용하더라도 구현하는 비용이 있음.
- 매핑하는 내부 동작방식을 리플렉션 뒤로 숨김 → 디버깅 고통
- 도메인 모델이 통신에 직접적으로 사용됨 → 바깥쪽 요구에 대한 변경에 취약
- 간단한 CRUD 유스케이스 → 규칙은 신성!!! 철저하게 준수 → 생산성 저하

> 어떤 매핑 전략도 철칙처럼 여겨져서는 안 된다. 그 대신 각 유스케이스마다 적절한 전략을 택할 수 있어야 한다.

---

# ‘완전’ 매핑 전략

- 각 연산마다 별도의 입출력 모델 사용
- 계층 간의 통신 → SendMoneyCommand 처럼 각 작업 특화 모델 사용

## 웹 계층의 책임

- 웹 계층 입력을 애플리케이션 계층으로 매핑 할 책임
- 커맨드 객체로 애플리케이션 계층 인터페이스 해석 필요 없음
    - 어떤 필드를 채울 것인가?
    - 어떤 필요를 비워두는 편이 좋은가?


## 애플리케이션 계층의 책임

- 애플리케이션 계층은 커맨드 객체를 도메인 모델로 변경 할 책임

## 장점

- 여러 유스케이스의 요구사항을 함께 다뤄야 하는 매핑에 비해 구현과 유지보수 쉬움

## 단점

- 다른 전략들에 비해 더 많은 코드가 필요

## 특성

- 전역으로 하기에는 무리
- 웹 계층과 애플리케이션 계층 사이 추천
- 애플리케이션 계층과 영속성 계층 사이는 비추천
    - 일반적으로 도메인 모델과 영속성 모델이 달라야 할 이유는 별로 없던 것 같다.
- 연산의 입력 모델만 사용하고 출력은 도메인 객체 그대로 이용
    - 웹 계층에서 까지 도메인 객체를 그대로 이용하는 것을 말하는 건 아닐 거라고 생각...

> 매핑 전략은 여러 가지를 섞어 쓸 수 있고, 섞어 써야만 한다. 어떤 매핑 전략도 모든 계층에 걸쳐 전역 규칙일 필요가 없다.

---

# ‘단방향’ 매핑 전략

- 모든 계층의 모델들이 같은 인터페이스를 구현
- 인터페이스는 getter 메서드 제공 → 도메인 모델 상태 캡슐화
- 이 전략의 매핑 책임은 한 쪽 방향으로만 향하고 있어서 ‘단방향' 매핑 전략

## 장점

- 도메인 모델 자체는 풍부한 행동을 구현 가능
- 애플리케이션 계층에서 이러한 행동 접근 가능
- 매핑 없이 각 계층간 객체 전달 가능
- 상태 변경 인터페이스 비노출 → 안전하게 바깥에서 사용 가능

## 단점

- 매핑이 전 계층을 넘나들며 퍼져 있음 → 개념적으로 어려움
    - 익숙해지면 명확하지 않을까 라는 생각도 함

## 특성

- 계층 간의 전략 모델이 비슷할 때 효과적
- 읽기 전용 연산의 경우 → 인터페이스가 필요한 모든 정보 제공 → 웹 계층에서 전용 모델로 매핑 할 필요 없음

# 언제 어떤 매핑 전략을 사용할 것인가?

- ‘그때 그때 다르다’ → 아니 이게 뭐람? 너무 무책임 하잖아 저자!
- 각 매핑 마다 장단점 있음 → 전역 규칙의 충동 이겨내야 함
    - 패턴 섞음 → 어수선함 → 최선의 선택이 아님에도 깔끔 때문에 전역? → 무책임
- 시간이 지남 → 소프트웨어 변함 → 어제의 최선 != 오늘의 최선

- 팀 내에서 합의할 수 있는 가이드라인 정해야 함
    - 어떤 상황에서 어떤 매핑 전략을 선택 해야 하는가? 답할 수 있어야 함
    - 왜 해당 전략이 최우선인가? 설명 가능해야 함
    - 그래야 시간이 흘러도 유효한 선택인가 평가할 수 있음

## 변경 유스케이스 예시

- 웹 계층 → 애플리케이션 계층
    - 서로의 결합을 제거하기 위해서 ’완전 매핑’ 전략이 최우선 선택지
    - 유스케이스별 유효성 검증 규칙 명확 → 특정 유스케이스에 필요하지 않는 필드 신경 안써도 됨
- 애플리케이션 계층 → 영속성 계층
    - 매핑 오버헤드 줄이기 위해 ‘매핑하지 않기’ 전략이 최우선 선택지
    - 애플리케이션 계층에서 영속성 문제를 다뤄야 하게 되면 ‘양방향’ 매핑 전략으로 변경 → 결합 느슨

## 쿼리 유스케이스 예시

- 웹 계층 → 애플리케이션 계층, 애플리케이션 계층 → 영속성 계층
    - 매핑 오버헤드 줄이기 위해 ‘매핑하지 않기’ 전략이 최우선 선택지
    - 영속성이나 웹 문제를 다뤄야 하게 되면 ‘양방향’ 매핑 전략으로 변경


> 가이드 라인을 성공적으로 적용하려면 개발자들의 머릿속에 가이드라인이 잘 담겨 있어야 한다.
그러므로 가이드라인은 팀 차원에서 지속적으로 논의하고 수정해야 한다.

---

# 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

- 각 유스케이스에 대해 좁은 포트 사용 → 유스케이스 마다 다른 매핑 전략 사용 선택지 → 결합 느슨
- 특정 상황, 특정 시점 → 최선의 전략 선택
- 상황마다 매핑 전략 선택은 전역 매핑 보다 어려움
- 그렇지만, 분명한 가이드라인이 있다면 유지보수하기 쉬운 코드가 되는 보상

---

# 느낀점

- 예외상황이 생길 수록 전략 선택에 대한 우선순위가 복잡해지지는 않을까? 라는 생각
- 복잡해지면, 각 상황마다의 전략을 기록 해놔야 하는거 아닐까?
- 그러면, 이런 상황이 되려나 하는 생각이 드는게...
    - 자, 지금 이런 상황에 ‘완전’ 매핑 전략으로 하셨는데
    - 우리 기록해놓은거 봐보면, 이 상황은 ‘단방향’ 매핑 전략으로 하기로 했으니까
    - ‘단방향’ 매핑 전략으로 변경해줘야 할 것같은데, 어떻게 생각하세요?