# Money 회고

- Money 예제를 만든 과정과 그 결과를 다시 한번 돌아보자. 이 장에서는 다음과 같은 내용을 이야기할 것이다.
  - 다음에 할일은 무엇인가.
  - 메타포 - 설계 구조에 미치는 메타포의 엄청난 영향.
  - JUnit 사용도 - 언제 테스트를 실행했으며, JUnit을 어떻게 사용해 왔는가.
  - 코드 메트릭스(metrics) - 결과 코드의 수치화.
  - 프로세스 - 빨강/초록/리팩토링 순서에 대해 이야기했는데, 그렇다면 각 단계에서 얼마 만큼 작업해야 하는가.
  - 테스트의 질 - 전통적인 테스트 메트릭스에 TDD 테스트가 어떻게 필적할 수 있는가.
  
## 다음에 할 일은 무엇인가

- 이제 코딩은 끝난 걸까? 아직 아니다. `Sum.plus()`와 `Money.plus()`사이에 지저분한 중복이 남았다.
- Expression을 인터페이스 대신 클래스로 바꾼다면 (보통 클래스가 인터페이스로 바뀌는 일이 자은데, 그 반대로 바뀌는 것은 일반적이 방향이 아니다) 공통되는 코드를 담아낼 적절한 곳이 될 것이다.
- 난 "끝났다"는 말을 믿지 않는다. TDD를 완벽을 위한 노력의 일환으로 사용할 수도 있겠지만 그건 TDD의 가장 효과적인 용법이 아니다.
- 만약 시스템이 크다면, 당신이 늘 건드리는 부분들은 절대적으로 견고해야 한다. 그래야 나날이 수정할 때 안심할 수 있기 떄문이다.
- 당신이 그 시스템의 가장자리, 자주 바뀌지 않는 부분으로 홀러감에 따라, 테스트는 더 듬성듬성 불규칙적이게 되고 디자인도 더 안좋아지지만 안심할 수 있다.


- "다음에 할일은 무엇인가?"에 관련된 또 다른 질문은 "어떤 테스트들이 추가로 더 필요할까?"다.
- 떄로는 실패해야 하는 테스트가 성공하는 경우가 있는데, 그럴 땐 그 이유를 찾아내야 한다.
- 또는 실패해야 하는 테스트가 실제로 실패하기도 하는데, 이때는 이를 이미 알려진 제한사항 또는 앞으로 해야 할 작업 등의 의미로 그 사실을 기록해둘 수도 있다.
- 마지막으로, 할일 목록이 빌 때가 그때까지 설계한 것을 검토하기에 적절한 시기다.
- 말과 개념이 서로 잘 통하는가? 현재의 설계로는 제거하기 힘든 중복이 있는가? (질질 끌며 남아 있는 중복은 잠복성 디자인의 증후다.)


## 메타포

- Money 예제를 코딩하면서 가장 놀라운 점은 이번 Money 예제의 결과가 기존에 했던 것과 많이 다르다는 것이다.
- 이 책을 준비하는 동안에만 서너 번 정도 짜봤다. 그리고 지금 이 글을 쓰는 동안 'expression(수식)' 메타포를 생각했는데, 설계가 기존과는 완전히 다른 방향으로 흘렀다.
- 정말 메타포가 이 정도로 막강할 거라고는 생각하지 못했다. 메타포라는 건 단지 이름들을 얻어 내는 데 필요한 것일 뿐이지 않은가? 절대 그렇지 않다.
- '통화가 다른 여러 금전'에 대해 워드 커닝엄이 사용한 메타포는 벡터였다(수학의 벡터 같은데 계수가 x<sup>2</sup>이 아니고 통화인 것).
- 난 얼마 동안은 `MoneySum`을 사용하다가, 적절하고 물리적인 `MoneyBag`으로 바꿨다. 그리고 마지막에는 대다수의 사람들에게 더 익숙할 `Wallet`으로 바꿨다.
- 이 모든 메타포는 Money의 집합이 딱 떨어지는 숫자로 된다는 걸 암시한다.
- 예를 들어 '2USD + 5CHF + 3USD'의 결과는 '5USD + 5CHF'일 것이다. 같은 통화의 값은 합칠 수 있다.
- Expression 메타포는 중복되는 통화를 합치는 세세한 일단의 문제에서 날 해방시켰다. 코드도 그 어느 때보다도 더 명확해졌다.
- 나는 수식의 성능에 대해 우려했지만 최적화를 시작하기 전에 어느 정도의 사용 통계를 볼 때까지 기다리는 것에 만족한다.
- 내가 지금까지 작성한 모든 프로그램을 20번씩 다시 작성해본다면 어떨까?
- 매번 새로운 통찰을 얻고 놀라움을 경험할 것인가?
- 더 신중을 기해서 모든 통찰을 처음 세 번 안에 다 얻어낼 바업ㅂ이 있을까? 아니면 한번에?


## Junit 사용도

- Money 예제를 코딩하는 동안 JUnit이 로그를 기록하게 해 두었다. 실행버튼을 정확히 125번 눌렀다.
- 코딩하는 동안에 이 글을 쓰는 일도 같이 했기 떄문에 시간 간격은 별로 정확하지 않겠지만,
- 보통 일분에 한 번 정도는 테스트를 실행했다.
- 그 전체 시간 중 점알 가끔 나는 성공 혹은 실패를 보고 놀랐는데, 그것은 조급하게 리팩토링을 한 경우였다.


## 코드 메트릭스

1. 전체 API를 다 구현한 게 아니기 때문에 함수의 수나 클래스당 함수의 수, 클래스당 줄 수 등을 절대적으로 평가할 수는 없다. 하지만 그 상대적인 비율에서 교훈을 얻을 수 있을 것이다. 코드와 테스트 사이에 대략 비슷한 양의 함수와 줄이 있는 것을 알 수 있다.
2. 테스트 코드의 줄 수는 공통된 테스트 픽스처를 뽑아내는 작업을 통해 줄일 수 있다.


## 프로세스

- TDD의 주기는 다음과 같다.


- 작은 테스트를 추가한다.
- 모든 테스트를 실행하고 실패하는 것을 확인한다.
- 코드에 변화를 준다.
- 모든 테스트를 실행하고, 성공하는 것을 확인한다.
- 중복을 제거하기 위해 리팩토링한다.


## 테스트의 질

- TDD의 부산물로 자연히 생기는 테스트들은 시스템의 수명이 다할 때까지 함께 유지돼야 할 만큼 확실히 유용하다.
- 하지만 이 테스트들이 다음과 같은 종류의 테스트들을 대체할 수 있을 거라고 예상해서는 안 된다.
  - 성능 테스트
  - 스트레스 테스트
  - 사용성 테스트
- 그렇지만 만약 테스트 주도 코드의 결함 밀도가 충분히 낮다면 전문 테스팅의 역할은 필연적으로 '어른의 감시'에서, 의사소통의 증폭기에 좀 더 가까운 무언가로 바뀌게 될 것이다.
- 여기에서 의사소통이란, 시스템이 무엇을 해야 하는지에 대해 일반적으로 어떤 느낌을 갖고 있는 사람들과 시스템이 실제로 그 일을 하도록 만들 사람들 간의 의사소통이다.


- 명령문 커버리지(statement coverage)는 테스트의 질에 대한 충분한 평가 기준이 될 수 없음이 확실하지만, 테스트의 시작점이다. TDD는 100% 명령문 커버리지를 종교적으로 따른다.
- 결함 삽입(defect insertion)은 테스트의 질을 평가하는 또 다른 방법이다. 원리는 간다한다. 코드의 의미를 바꾼 후에 테스트가 실패하는지 보는 것이다.
- 이 작업은 수동을 할 수도 있지만 Jester 같은 툴을 사용할 수도 있다.


- 이 책의 리뷰어 중 한 사람인 플립이 테스트 커버리지에 대해 한 이야기가 있는데, 여기서 되풀이할 가치가 있다.
- 전체 커버리지 수치는 프로글매의 서로 다른 경우를 테스트하는 테스트 수를 테스팅이 필요한 경우의 수(로직의 복잡도)로 나눈 것이다.
- 테스트 커버리지를 향상시키는 한 가지 방법은 더 많은 테스트를 작성하는 건데, 테스트 주도 개발자가 작성 하는 테스트 코드의 수와 전문 테스터가 작성하는 테스트 코드의 수 사이의 엄청난 차이가 여기에서 온다.
- 테스트 커버리지를 향상시키는 또 다른 방법은 테스트의 수는 그대로 두면서 프로그램 로직을 단순화하는 것이다.
- 리팩토링 단계가 종종 다음과 같은 효과를 가져온다.
- 조건문이 메시징으로 바뀌거나 아예 사라진다.


## 최종 검토

- TDD를 가르칠 때 사람들이 자주 놀라는 세 가지는


- 테스트를 확실히 돌아가게 만드는 세 가지 접근법: 가짜로 구현하기, 삼각측량법, 명백하게 구현하기.
- 설계를 주도하기 위한 방법으로 테스트 코드와 실제 코드 사이의 중복을 제거하기.
- 길이 미끄러우면 속도를 줄이고 상황이 좋으면 속도를 높이는 식으로 테스트 사이의 간격을 조절할 수 있는 능력.