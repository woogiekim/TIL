# 테스트 주도 개발 패턴

- 어떻게 테스트할 것인가에 대하여 자세히 이야기하기 전에 우선 기본적ㅇ니 전략에 관한 질문에 답해야 한다.
  - 테스트한다는 것은 무엇을 뜻하는가?
  - 테스트를 언제 해야 하는가?
  - 테스트할 로직을 어떻게 고를 것인가?
  - 테스트할 데이터를 어떻게 고를 것인가?


## 테스트(명사)

- 작성한 소프트웨어를 어떻게 테스트할 것인가? 자동화된 테스트를 만들어라.
- 테스트하다(test)는 '평가하다'라는 뜻의 동사다. 그 어떤 소프트웨어 엔지니어도, 아주 확신에 찬 사람과 정마 얼렁뚜땅 넘어가는 사람을 제외한다면,
- 아무리 작은 변화라도 테스트하지 않고 릴리즈하지는 않는다.
- 당신이 변화를 테스트할 수 있다고 해도, 실제로 변화를 테스트하는 것은 '테스트를 갖고 있다'는 것과 똑같지 않다.
- 테스트는 또한 '승인 또는 거부에 도달하는 과정'을 뜻하는 명사이기도 하다.
- 어째서 명사로서의 테스트(자동으로 실행되는 과정)가 동사로서의 테스트(버튼을 몇 개 눌러보고 화면에 나오는 결과를 주시하는)와 다른 느낌을 주는 걸까?


- 스트레스를 많이 받으면 테스트를 점점 더 뜸하게 한다.
- 테스트를 뜸하게 하면 당신이 만드는 에러는 점점 많아질 것이다.
- 에러가 많아지면 더 많은 스트레스를 받게 된다. 씻어내고 다시 반복하라(rinse and repeat)


- 어떻게 하면 이 고리에서 빠져나올 수 있을까? 새로운 요소를 도입하거나, 기존 요소와 바꿔치기 하거나, 화살표를 바꾸면 된다.
- 이 경우엔 '테스트'를 '자동화된 테스트'로 치환하면 된다.


- "내가 이걸 고치면서 뭔가 다른 부분을 망가트리지 않았을까?" 자동화된 테스트가 있다면, 스트레스를 받기 시작할 때 테스트를 실행할 것이다.
- 테스트는 프로그래머를 위한 묘석인데, 두려움을 지루함으로 바꿔주는 효험이 있다. "음, 아무 문제 없군. 테스트가 여전히 초록 막대야."
- 스트레스를 더 많이 받을수록 테스트도 더 많이 실행한다. 테스트를 실행하면 즉시 좋은 느낌을 받게 되고 그러면 작업 중에 에러를 낼 일도 줄게 되며, 스트레스도 적어진다.
- "테스트할 시간이 어딨어. 그냥 릴리즈해!" 이 장면에 대해서는 결과를 보장할 수 없다.
- 스트레스를 점점 많이 받으면 결국 시패하게 된다. 그러나 자동화된 테스트가 있다면 두려운 정도를 선택할 수 있다.


## 격리된 테스트

- 테스트를 실행하는 것이 서로 어떤 식으로 영향을 미쳐야 좋은가? 아무 영향이 없어야 한다.

- 하나는 테스트가 충분히 빨라서 내가 직접, 자주 실행할 수 있게끔 만들자는 것이다.
- 둘째 교훈은 어마어마한 양의 종이더미가 반드시 어마어마한 양의 문제를 의미하는 것은 아니라는 점이다.
- 앞 부분에서 실행된 테스트가 실패한 후 그 영향으로 다음 테스트부터는 시스템이 예측 불가능한 상태에 놓이는 경우가 허다하다.


- 이 문제르 해결하기 위해 각 테스트 사이에서 매번 시스템을 재가동하는 방법을 써봤지만 시간이 너무 오래 걸렸다.
- 이로 인해 또 다른 교훈을 얻었는데, 테스트는 전체 애플리케이션을 대상으로 하는 것보다 좀더 작은 스케일로 하는 게 좋다는 것이다.
- 어쨌건 주된 교훈은 각각의 테스트는 다른 테스트와 완전히 독립적이어야 한다는 것이다. 즉 문제가 하나면 테스트도 하나만 실패해야 하고, 문제가 둘이면 테스트도 두 개만 실패해야 한다.


- 격리된 테스트가 암묵적으로 내포하는 특징 중 하나는 테스트가 실행순서에 독립적이게 된다는 점이다.
- 격리된 테스트가 내포하는 게 또 하나 있는데, 이는 주어진 문제를 작은 단위로 분리하기 위해 노력해서(때론 매우 많은 노력이 필요하다)각 테스트를 실행하기 위한 환경을 쉽고 빠르게 세팅할 수 있게 해야 한다는 것이다.
- 테스트를 격리하기 위한 작업은 결과적으로 시스템이 응집도는 높고 결합도는 낮은 객체의 모음으로 구성되도록 한다.


## 테스트 목록

- 뭘 테스트해야 하나? 시작하기 전에 작성해야 할 테스트 모곡을 모두 적어둘 것. 프로그래밍 스트레스를 줄이기 위한 우리 접근법의 첫 단계는 발 디딜 곳이 확실해지기 전엔 결코 발을 떼어 전진하지 말자는 것이다.


- 목표에서 벗어나지 않고 집중할 수 있는 한 가지 전략은 모든 걸 머릿속에 넣어 두는 것이다. 이 방법을 몇 년간 시도해본 결과 양성 피드백 고리에 빠지게 된다는 것을 알게 됐다.
- 경험이 축적될수록 할일 목록이 많아진다. 할일 목록이 많아질수록 내가 하던 일에 대한 집중력이 떨어지고 성취도는 낮아진다. 성취도가 낮아지면 할일 목록은 더 많아진다.
- 그냥 머릿속에 있는 목록에서 임임의 항목을 무시하고 변덕스럽게 프로그래밍 해봤지만, 이 고리는 깨지는 못했다.
- 나는 향후 몇 시간 내로 해치워야 하는 모든 할일 목록을 컴퓨터 옆에 있는 종이 조각에 적어놓는 습관을 갖게 됐다.


- 이를 테스트 주도 개발에 적용해보면, 구현해야 할 것들에 대한 테스트를 목록에 적게 된다. 우선 구현할 필요가 있는 모든 오퍼레이션의 사용예들을 적는다.
- 그 다음, 이미 존재하지 않는 오퍼레이션에 대해서는 해당 오퍼레이션의 널 버전(아무 일도 하지 않는 버전)을 리스트에 적는다.
- 마지막으로 깔끔한 코드를 얻기 위해 이번 작업을 끝내기 전에 반드시 해야 할 리팩토링 목록을 적는다.


- 테스트를 한번에 다 만들어 놓는 방법이 먹히지 않았던 두 가지 이유가 있다.
- 첫째, 만들어진 모든 테스트는 리팩토링에 대해 약간의 관성을 갖는다. 자동화된 리팩토링 도구가 있다면 이것은 별 문제가 안 된다. 그렇지 않다면 열 개의 테스트를 만든 후에 매개 변ㅅ의 순서를 반대로 하는 게 좋을 거라는 사실을 발견하더라도 여러분은 아마 이 순서를 바꾸지 않으려 할 것이다.
- 둘째, 열개의 테스트가 실패했다면 초록 막대를 보는 것은 한참 멀었다. 빨리 초록 말대를 볼 방법은 열 개의 테스트를 몽땅 지워버리는 것뿐이다. 만약 모든 테스트가 통과하도록 하려면 오랫동안 빨간 막대 상태에 머물러야 한다.
- 만약 여러분이 초록 막대에 중독돼서 초록 막대를 보기 전에는 잠자리에 들 수 없을 지경이라면 이 시간은 영원과도 같은 것이다.


## 테스트 우선

- 테스트를 언제 작성하는 것이 좋을까? 테스트 대상이 되는 코드를 작성하기 직전에 작성하는 것이 좋다.
- 코드르 작성한 후에는 테스트를 만들지 않을 것이다. 프로그래머로서 여러분의 목표는 기능이 실행되도록 만드는 것이다.
- 하지만 또 한편으로는 프로그램의 설계에 대해 생각해볼 시간도 필요하고 작업 범위를 조절할 방법도 필요할 것이다.


## 단언 우선

- 테스트를 작성할 때 단언은 언제쯤 쓸까? 단언을 제일 먼저 쓰고 시작하라.
- 자기유사성이란 참 멋지지 않은가?
  - 시스템을 개발할 때 무슨 일부터 하는가? 완료된 시스템이 어떨 거라고 알려주는 이야기부터 작성한다.
  - 특정 기능을 개발할 때 무슨 일부터 하는가? 기능이 완료되면 통과할수 있는 테스트부터 작성한다.
  - 테스트를 개발할 때 무슨 일부터 하는가? 완료될 때 통과해야 할 단언부터 작성한다.

- 단언을 먼저 작성하면 작업을 단순하게 만드는 강력한 효과를 볼 수 있다. 구현에 대해 전혀 고려하지 않고 테스트만 작성할 때도 사실 여러분은 몇 가지 문제들을 한번에 해결하는 것이다.
  - 테스트하고자 하는 기능이 어디에 속하는 걸까? 기존의 메소드를 수정해야 하나, 기존의 클래스에 새로운 메소드를 추가해야 하나, 아니면 이름이 같은 메소드를 새 장소에? 또느 새 클래스에?
  - 메소드 이름은 뭐라고 해야 하나?
  - 올바른 결과를 어떤 식으로 검사할 것인가?
  - 이 테스트가 제안하는 또 다른 테스트에는 뭐가 있을까?


## 테스트 데이터

- 테스트할 때 어떤 데이터를 사용해야 하는가? 테스트를 읽을 때 쉽고 따라하기 좋을 만한 데이터를 사용하라.
- 테스트 작성에도 청중이 존재한다. 단지 데이터 값을 산발하기 위해 데이터 값을 산발하지 마라. 데이터 간에 차이가 있다면 그 속에 어떤 의미가 있어야 한다.
- 1과 2사이에 어떠한 개념적 차이점도 없다면 1을 사용하라.


- 테스트 데이터 패턴이 완전한 확신을 얻지 않아도 되는 라이선는 아니다. 만약 시스템이 여러 입력을 다루어야 한다면 테스트 역시 여러 입력을 반영해야 한다.
- 하지만 세 항목만으로 동일한 설계와 구현을 이끌어 낼수 있다면 굳이 항목을 열 개나 나열할 필요는 없다.


- 테스트 데이터 패턴의 한 가지 트릭은 여러 의미를 담는 동일한 상수를 쓰지 않는 것이다. 만약 plus() 메소드를 구현하려고 한다면 고전적 예제인 2+2 혹은 1+1을 쓰고 싶을 것이다.
- 만약 구현에서 인자의 순서가 뒤집힌다면 어떻게 될까?


- 테스트 데이터에 대한 대안은 실제 세상에서 얻어진 실제 데이터를 사용하는 것이다. 실제 데이터는 다음과 같은 경우에 유용하다.
  - 실제 실행을 통해 수집한 외부 이벤트의 결과를 이용하여 실시간 시스템을 테스트하고자 하는 경우.
  - 예전 시스템의 출력과 현재 시스템의 출력을 비교하고자 하는 경우 (병렬 테스팅).
  - 시뮬레이션 시스템을 리팩토링한 후 기존과 정확히 동일한 결과가 나오는지 확인하고자 할 경우. 특히 부동소수점 값의 정확이 문제가 될 수 있다.


## 명백한 데이터

- 데이터의 의도를 어떻게 표현할 것인가? 테스트 자체에 예상되는 값과 실제 값을 포함하고 이 둘 사이의 관계를 드러내기 위해 노력하라.
- 테스트를 작성할 때는 컴퓨터뿐 아니라 후에 코드를 읽을 다른 살마들도 생각해야 한다. 수십 년 후 누군가 와서(혹은 자기가 예전에 만든 코드를 보며) 질문할 것이다.
- "대체 이 자식이 뭔 생각으로 이 코드를 만든거야?" 이 짜증내는 사람이 여러분 자신이 될 수도 있다는 것을 생각하면 코드에 될 수 있는 한 많은 실마리를 남기고 싶을 것이다.


```java
Bank bank = new Bank();
bank.addRate("USD", "GBP", STANDARD_RATE);
bank.commission(STANDARD_COMMISSION);
Money reuslt = bank.convert(new Note(100, "USD"), "GBP");
assertEquals(new Note(49.25, "GBP"), result);
```

- 또는 계싼을 더 명확히 표현할 수도 있다.


```java
Bank bank = new Bank();
bank.addRate("USD", "GBP", 2);
bank.commission(0.015);
Money reuslt = bank.convert(new Note(100, "USD"), "GBP");
assertEquals(new Note(100 / 2 * (1 - 0.015), "GBP"), result);
```

- 이 테스트에서는 입력으로 사용된 숫자와 예상되는 결과 사이의 관계를 읽어낼 수가 있다.


- 명백한 데이터가 주는 또 다른 이점은 프로그래밍이 더 쉬워진다는 것이다. 단언 부분에 일단 수식을 써놓으면 다음으로 무엇을 해야 할지 쉽게 알게 된다.
- 이런 경우 어떻게든 나눗셈과 곱셈을 수행할 프로그램을 만들어야 한다는 걸 알게 되는 것이다.
- 이 오퍼레이션이 어디에 속할지를 점진적으로 알아내기 위해 가짜 구현을 해볼 수도 있다.


- 명백한 데이터 코드에 매직넘버를 쓰지 말라는 것에 대한 예외적인 규칙일 수도 있다. 단일 메소드의 범위에서라면, 5라는 숫자(어떤 매직넘버) 사이의 관계를 명백하다.
- 하지만 이미 정의된 기호 상수가 있다면 나는 그것을 사용할 것이다.