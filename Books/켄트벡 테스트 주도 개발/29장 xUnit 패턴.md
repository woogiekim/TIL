# xUnit 패턴

## 단언(assertion)

- 예전에 `assertTrue(rectangle.area() != 0)`와 같은 혀앹의 단언을 본 적이 있다.
- 이 경우 0이 아닌 아무 값이나 반환하게 만들어도 조건을 만족하므로 이 단언은 별로 유용하지 않다.
- 단언은 구체적이어야 한다.
- 만약 면적(area)이 50이어야 한다면, 다음과 같이 면적이 50이어야 한다고 적어주어야 한다. `assertTrue(rectangle.area() == 50)`
- 객체를 블랙박스처럼 취급하기란 쉽지 않다.
- 청약됨(Offered) 혹은 시행중(Running)이라는 상태(Status)를 가질 수 있는 계약(Contract)에 대한 테스트를 작성한다고 생각해보자.
- 아마 다음과 같이 작성할 것이다.

```java
Contract contract=new Contract(); // 디폴트로 Offered status
        contract.begin();
        assertEquals(Running.class,contract.status.class);
```

- 이 테스트는 status에 대한 현재 구현에 너무 의존적이다.
- status가 boolean 값으로 표현되도록 구현이 바뀌더라도 테스트가 통과할 수 있어야 한다.
- 아마도 status가 Running으로 바뀐다면 시행일이 언제인지 알아낼 수 있을 것이다.

```java
assertEquals(...,contract.startDate()); // status가 Offered라면 예외
```

## 픽스쳐

- 여러 테스트에서 공통으로 사용하는 객체들을 생성할 때 어떻게 하면 좋을까?
- 각 테스트 코드에 있는 지역 변수를 인스턴스 변수로 바꾸고 setUp() 메소드를 재정의하여 이 메소드에서 인스턴스 변수들을 초기화하도록 한다.
- 종종 객체들을 원하는 상태로 세팅하는 코드를 작성하고 나서, 이 객체들을 조작하고 결과를테스트하는 코드를 만든다.
- 그런데 객체들을 세팅하는 코드는 여러 테스트에 걸쳐 동일한 경우가 있다.
- 이러한 객체들은 테스트 픽스쳐(fixture, 정착물 혹은 고정물) 혹은 발판(scaffolding)이라 부른다.
- 이와 같은 중복은 다음과 같은 이유로 좋지않다.
    - 복사해서 붙이기를 한다고 하더라도 이런 코드를 반복 작성하는 것엔 시간이 소요된다.
    - 인터페이스를 수동으로 변경할 필요가 있을 경우, 여러 테스트를 고쳐주어야 한다.
- 하지만 중복이 좋은 점도 존재한다. 객체 세팅 코드들이 단언이 적힌 메소드에 포함되면 우리는 테스트 코드를 그냥 위에서 아래로 읽어내려 갈 수 있다.

## 외부 픽스쳐

- 픽스처 중 외부 자원이 있을 경우 이를 어떻게 해제(release)할 것인가?
- testDown() 메소드를 재정의하여 이곳에서 자원을 해제하면 된다.

## 테스트 메소드

- 테스트 케이스 하나를 어떻게 표현할 것인가? 'test'로 시작하는 이름의 메소드로 나타내면 된다.

## 예외 테스트

- 예외가 발생하는 것이 정상인 경우에 대한 테스트는 어떻게 작성할 것인가?
- 예상되는 예외를 잡아서 무시하고, 예외가 발생하지 않은 경우에 한해서 테스트가 실패하게 만들면 된다.

## 전체 테스트

- 모든 테스트를 한 번에 실행하려면 어떻게 해야 할까?
- 모든 테스트 슈트에 대한 몽므을 작성하면 된다.
- 각각 패키지에 대해 하나씩, 그리고 전체 애플리케이션의 패키지 테스트를 모아주는 테스트 슈트
- gradle 이나 mvn 에서 전체 테스트를 수행할 수 있기 때문에 딱히 필요 없을 것 같음.
