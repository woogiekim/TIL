# 디자인 패턴

- 패턴의 주요한 통찰이 하나 있으니,
- 우리가 언제나 완전히 다 문제들을 해결하는 것 같지만 우리가 푸는 문제 대다수는 사용하는 도구에 의해 생기는 것이지
- 직면한 외부의 문제 떄문에 생기는 것이 아니라는 점이다.

## 커맨드

- 간단한 메소드 호출보다 복잡한 형태의 계산 작업에 대한 호출이 필요하다면 어떻게 해야 할까?
- 계산 작업에 대한 객체를 생성하여 이를 호출하면 된다.
- 예를 들어 메시지를 보냈다는 사실을 로그로 남기길 원한다고 생각해보자
- 물론 언어에 새로운 특성(wrapper method)을 추가하는 방법도 있겠지만, 그러기엔 로깅 기능이 쓰이는 빈도가 매우 낮고,
- 이에 비해서 간결한 언어가 우리에게 주는 가치는 너묻 높기 떄문에,
- 언어에 새로운 특성을 추가하지 않는 게 좋을 것이다.
- 또 다른 예를 들자면, 어떤 계산을 수행하고 싶긴 한데 나중에 하고 싶은 경우도 있다.
- 이 경우에 새로운 스레드를 생성하고 멈춘 후에 나중에 원하는심저에서 다시 시작할 수 있겠지만,
- 이렇게 한다면 우린 온갖 동시성 무넺를 고민해야 할 것이다.
- 복잡한 계산 작업 호출은 값비싼 메커니즘을 필요로 한다.
- 하지만 거의 대부분의 경우 이런 모든 복잡함이 요구되지는 않으며, 그런 비싼 값을 치르지 않는 게 좋을 것이다.
- 메시지 하나를 보내는 것보다 호출이 조금 더 구체적이고 또 조작하기 쉬워지려면, 바로 객체가 해답이 된다.
- 호출 자체를 나타내기 위한 객체를 만드는 것이다.

## 값 객체

- 널리 공유해야 하지만 동일성(identity)은 중요하지 않을 때 객체를 어떤 식으로 설계할 수 있을까?
- 객체가 생성 될 떄 객체의 상태를 설정한 후 이 상태가 절대 변할 수 없도록 한다.
- 그리고 이 객체에 대해 수행되는 연산은 언제나 새로운 객체를 반환하게 만든다.
- 두 객체가 재삼의 다른 객체에 대한 참조를 공유하고 있는데, 한 객체가 공유되는 객체의 상태를 변화시키면
- 나머지 다른 객체는 공유 객체의 상태에 의존하지 않는 편이 차라리 나을 것이다.
- 해결하기 위한 방법으로 현재 의존하는 객체에 대한 참조를 결코 외부로 알리지 않는 방법이다.
- 그 대신 객체에 대한 복사본을 제공하는 것이다. 이 방법은 시간(수행 시간)이나 공간(메모리 공간) 측면에서 비싼 해결책일 수도 있고,
- 공유 객체의 상태 변화를 공유하고 싶은 경우에는 사용할 수 없다는 단점이 있다.
- 또 다른 방법은 옵저버 패턴을 사용하는 것이다.
- 의존하는 객체에 자기를 등록해 놓고, 객체의 상태가 변하면 통지를 받는 방법이다.
- 옵저버 패턴은 제어 흐름을 이해하기 어렵게 만들 수 있고, 의존성을 설정하고 제거하기 위한 로직이 지저분해질 수 있다.
- 또 다른 해법은 객체를 덜 객체답게 취급하는 법이다.
- 객체는 시간의 흐름에 따라 변할 수 있는 상태를 갖고 있다. 하지만 만약 우리가 원한다면 '시간의 흐름에 따라 변하는 상태'를 제거해버릴 수 있다.
- 객체가 변하지 않을 것임을 안다면 이 객체에 대한 참조를 원하는 곳 어디로든 넘겨줄 수 있다.
- 변화 자체가 불가능하다면 내가 모르는 곳에서 변화가 일어날 가능성 자체가 없게 되는 것이다.
- 값 객체를 구현할 떄 모든 오퍼레이션은 기존 객체는 변하지 않는 채로 놔두고, 새로운 객체를 반환해야 한다.
- 모든 값 객체는 동등성을 구현해야 한다(그리고 많은 언어에서 값 객체는 암묵적으로 해싱으 구현해야 한다.)
    - 자바에서는 컬렉션에서 동등성 확인을 할때 hashCode 를 이용해서 확인하기 때문에 동등성 구현을 하려고 하면
    - equals 와 hashCode 둘다 재정의 해주는 것이 좋다.

## 널 객체

- 객체의 특별한 상황을 표현하고자 할 때 어떻게 해야 할까?
- 그 특별한 상황을 표현하는 새로운 객체를 만들면 된다.
- 그리고 이 객체에 다른 정상적인 상황으 나타내는 객체와 동일한 프로토콜을 제공한다.

## 템플릿 메서드

- 작업 순서는 변하지 않지만 각 작업 단위에 대한 미래의 개선 가능성을 열어두고 싶은 경우 이를 어떻게 표현할 것인가?
- 다른 메소드들을 호출하는 내용으로만 이루어진 메소드를 만든다.

## 플러거블 객체

- 변이를 어떻게 표현할 것인가?
- 가장 간단한 방법은 명시적인 조건문을 사용하는 것이다.
- 하지만 이러한 명시적인 의사 결정 코드는 소스의 여러 곳으로 퍼져나간다는 사실을 순식간에 알게 될 것이다.
- 원과 원이 아닌 것을 구분하기 위해 한 곳에서 명시적인 조건문을 사용하게 되면,
- 조건문은 조만간 퍼져나갈 것이다.
- TDD의 두 번째 수칙이 중복을 제거하는 것이기 때문에, 명시적인 조건문이 전염되는 싹을 애초에 잘라버려야 한다.

## 플러거블 셀렉터

- 인스턴스별로 서로 다른 메소드가 동적으로 호출되게 하려면 어떻게 해야할까?
- 메소드의 이름을 저장하고 있다가 그 이름에 해당하는 메소드를 동적으로 호출한다.
- switch 문을 이용

```java
abstract class Report {
    String printMessage;

    Report(String printMessage) {
        this.printMessage = printMessage;
    }

    void print() {
        switch (printMessage) {
            case 'printHTML':
                printHTML();
                break;
            case 'printXML':
                printXML();
                break;
        }
    }

    void printHTML() {
    }

    void printXML() {
    }
}
```

- 이 방법은 새로운 종류의 출력을 추가할 때마다 출력 메소드를 추가하고 switch 문을 바꿔야 한다는 점을 기억해야 한다.
- 플러거블 셀렉터 해법은 리플렉션을 이용하여 동적으로 메소드를 호출하는 것이다.

```java
abstract class Report {
    String printMessage;

    void print() {
        Method runMethod = getClass().getMethod(printMessage, null);
        runMethod.invoke(this, new Class[0]);
    }
}
```

## 팩토리 메소드

- 새 객체를 만들 때 유연성을 원하는 경우 객체를 어떻게 생성하는가?
- 생성자를 쓰는 대신 일반 메소드에서 객체를 생성한다.
- 생성자는 자신을 잘 표혆나다. 생성자를 사용하는 경우 분명히 깨체 하나를 생성하고 있다는 것을 알 수 있다.
- 그러나 생성자는, 특히 자바에서 표현력과 유연함이 떨어진다.

## 사칭 사기꾼

- 기존 코드에 새로운 변이를 도입하려면 어떻게 해야 할까? 기존의 객체와 같은 프로토콜을 갖지만 규현은 다른 새로운 객체를 추가한다.

## 컴포지트

- 하나의 객체가 다른 객체 목록의 행위를 조합한 것처럼 행동하게 만들려면 어떻게 해야 할까?
- 객체 집합을 나타내는 객체를 단일 객체에 대한 임포스터로 구현한다.

## 수집 매개 변수

- 여러 객체에 걸쳐 존재하는 오퍼레이션의 결과를 수집하려면 어떻게 해야 할까?
- 결과가 수집될 객체를 각 오퍼레이션의 매개 변수로 추가한다.

## 싱글톤

- 전역 변수를 제공하지 않는 언어에서 전역 변수를 사용하려면 어떻게 해야 할까?
- 사용하지 마라.
- 프로그램은 당신이 전역 변수를 사용하는 대신 설계에 대해 고민하는 시간을 가졌던 점에 대해 감사할 것이다.