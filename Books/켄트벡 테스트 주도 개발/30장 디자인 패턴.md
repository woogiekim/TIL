# 디자인 패턴

- 패턴의 주요한 통찰이 하나 있으니,
- 우리가 언제나 완전히 다 문제들을 해결하는 것 같지만 우리가 푸는 문제 대다수는 사용하는 도구에 의해 생기는 것이지
- 직면한 외부의 문제 떄문에 생기는 것이 아니라는 점이다.

## 커맨드

- 간단한 메소드 호출보다 복잡한 형태의 계산 작업에 대한 호출이 필요하다면 어떻게 해야 할까?
- 계산 작업에 대한 객체를 생성하여 이를 호출하면 된다.
- 예를 들어 메시지를 보냈다는 사실을 로그로 남기길 원한다고 생각해보자
- 물론 언어에 새로운 특성(wrapper method)을 추가하는 방법도 있겠지만, 그러기엔 로깅 기능이 쓰이는 빈도가 매우 낮고,
- 이에 비해서 간결한 언어가 우리에게 주는 가치는 너묻 높기 떄문에,
- 언어에 새로운 특성을 추가하지 않는 게 좋을 것이다.
- 또 다른 예를 들자면, 어떤 계산을 수행하고 싶긴 한데 나중에 하고 싶은 경우도 있다.
- 이 경우에 새로운 스레드를 생성하고 멈춘 후에 나중에 원하는심저에서 다시 시작할 수 있겠지만,
- 이렇게 한다면 우린 온갖 동시성 무넺를 고민해야 할 것이다.
- 복잡한 계산 작업 호출은 값비싼 메커니즘을 필요로 한다.
- 하지만 거의 대부분의 경우 이런 모든 복잡함이 요구되지는 않으며, 그런 비싼 값을 치르지 않는 게 좋을 것이다.
- 메시지 하나를 보내는 것보다 호출이 조금 더 구체적이고 또 조작하기 쉬워지려면, 바로 객체가 해답이 된다.
- 호출 자체를 나타내기 위한 객체를 만드는 것이다.

## 값 객체

- 널리 공유해야 하지만 동일성(identity)은 중요하지 않을 때 객체를 어떤 식으로 설계할 수 있을까?
- 객체가 생성 될 떄 객체의 상태를 설정한 후 이 상태가 절대 변할 수 없도록 한다.
- 그리고 이 객체에 대해 수행되는 연산은 언제나 새로운 객체를 반환하게 만든다.
- 두 객체가 재삼의 다른 객체에 대한 참조를 공유하고 있는데, 한 객체가 공유되는 객체의 상태를 변화시키면
- 나머지 다른 객체는 공유 객체의 상태에 의존하지 않는 편이 차라리 나을 것이다.
- 해결하기 위한 방법으로 현재 의존하는 객체에 대한 참조를 결코 외부로 알리지 않는 방법이다.
- 그 대신 객체에 대한 복사본을 제공하는 것이다. 이 방법은 시간(수행 시간)이나 공간(메모리 공간) 측면에서 비싼 해결책일 수도 있고,
- 공유 객체의 상태 변화를 공유하고 싶은 경우에는 사용할 수 없다는 단점이 있다.
- 또 다른 방법은 옵저버 패턴을 사용하는 것이다.
- 의존하는 객체에 자기를 등록해 놓고, 객체의 상태가 변하면 통지를 받는 방법이다.
- 옵저버 패턴은 제어 흐름을 이해하기 어렵게 만들 수 있고, 의존성을 설정하고 제거하기 위한 로직이 지저분해질 수 있다.
- 또 다른 해법은 객체를 덜 객체답게 취급하는 법이다.
- 객체는 시간의 흐름에 따라 변할 수 있는 상태를 갖고 있다. 하지만 만약 우리가 원한다면 '시간의 흐름에 따라 변하는 상태'를 제거해버릴 수 있다.
- 객체가 변하지 않을 것임을 안다면 이 객체에 대한 참조를 원하는 곳 어디로든 넘겨줄 수 있다.
- 변화 자체가 불가능하다면 내가 모르는 곳에서 변화가 일어날 가능성 자체가 없게 되는 것이다.
- 값 객체를 구현할 떄 모든 오퍼레이션은 기존 객체는 변하지 않는 채로 놔두고, 새로운 객체를 반환해야 한다.
- 모든 값 객체는 동등성을 구현해야 한다(그리고 많은 언어에서 값 객체는 암묵적으로 해싱으 구현해야 한다.)
  - 자바에서는 컬렉션에서 동등성 확인을 할때 hashCode 를 이용해서 확인하기 때문에 동등성 구현을 하려고 하면
  - equals 와 hashCode 둘다 재정의 해주는 것이 좋다.