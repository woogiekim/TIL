# 리팩토링

- TDD에서는 리팩토링을 특이한 방법으로 사용한다.
- 일반적으로 리팩토링은 어떤 상황에서도 프로그램의 읨론을 변경해서는 안 된다.
- 하지만 TDD에서 우리가 신경 쓰는 부분은 현재 이미 통과한 테스트들뿐이다.
- 예를 들어 TDD에서는 상수를 변수로 바꾸고 양심에 꺼리낌 없이 이를 리팩토링이라고 한다.
- 왜냐하면 이 행위가 통과하는 테스트의 집합에 아무 변화도 주지 않기 떄문이다.
- 의미론이 유지되는 상황이란 사실 태스트 케이스 하나일 수도 있다.
- 그럴 떄 이전에 통과한 다른 테스트 케이스들은 실패하게 될 것이다.
- 하지만 우린 아직 나머지 테스트를 만들지 않았기 때문에 이 테스트들에 대해서는 걱정할 필요가 없다.
- 이 '관측상의 동치성'이 성립되려면 충분한 테스트를 가지고 있어야 한다.
- 여기에서 충분한 테스트란, 현재 가지고 있는 테스트들에 기반한 리팩토링이 추측 가능한 모든 테스트에 기반한 리팩토링과 동일한 것으로 여겨질 수 있는 상태를 말한다.
- "문제가 있다는 건 알지만 테스트는 모두 통과하니까 일단 CVS에 체크인 해야지."하고 말할 수는 없다.
- 만약 그런 생각이 든다면 테스트를 더 만들어야 한다.

## 차이점 일치시키기

- 비슷해 보이는 두 코드 조각을 하빛려면 어떻게 해야 할까?
- 두 코드가 단계적으로 닮아가게끔 수정한다.
- 이 둘이 완전히 동일해지면 둘을 합친다.
- 우리가 작은 단계와 명확한 피드백을 이용해서 피해가고자 하는 일이 바로, 불확실한 믿음에 의지하여 단계를 크게 건더뛰는 리팩토링이다.
- 물로 이런 크게 도약하는 리팩토링을 완전히 피할 수는 없겠지만, 발생 빈도를 줄일 수는 있다.
    - 두 반복문의 구조가 비슷하다. 이 둘을 동일하게 만드록 나서 하나로 합친다.
    - 조건문에 의해 나눠지는 두 분기의 코드가 비슷하다. 이 둘을 동일하게 만들고 나서 조건문을 제거한다.
    - 두 클래스가 비슷하다. 이 둘을 동일하게 만들고 나서 하나를 제거한다.
- 간혹 차이점 일치시키기를 거꾸로 수행해야 하는 경우도 있다.
- 이 말은, 변경 마지막 단계에 사소한 것만 처리하게 하려면 어떤 모양새가 되어야 할까 생각한 다음 거꾸로 거슬러 온다는 것이다.
- 예를 들어 여러 개의 하위 클래스를 제거하길 원한다고 치자. 하위 클래스의 내용이 비어 있다면 마지막 작업은 간단할 것이다.
- 그러면 단지 하위 클래스에 대한 참조를 상위 클래스로 바꿔주기만 하면 된다.
- 이 작업은 시스템 행위를 변경하지 않을 것이다.
- 하위 클래스의 내용이 비어 있으면 메소드의 내용이 상위 클래스의 메소드 내용과 동일하면 된다.
- 하나씩 하나씩 하위 클래스의 내용을 비우고, 모두 비게 되면 하위 클래스에 대한 참조를 상위 클래스로 바꾼다.

## 변화 격리하기

- 객체나 메소드의 일부만 바꾸려면 어떻게 해야 할까? 일단, 바꿔야 할 부분을 격리한다.
- 머릿속에 수술에 장면이 떠오른다. 수술 부위만 빼고 환자의 온몸은 천으로 덮여있다.
- 그렇게 천을 가리는 것은 어떤 고정된 변수 몇 가지만을 외과의사에게 노출시키는 것과 같다.
- 자, 한 사람을 좌 하단 복부로 추상화하는 것이 훌륭한 의료로 이어지는지에 대해 기나긴 논쟁을 할 수도 있겠지만,
- 나는 수술 시점에 그 외과의사가 집중할 수 있다는 점이 기쁘다.

## 데이터 이주시키기

- 표현 양식을 변경하려면 어떻게 해야 할까?
- 일시적으로 데이터를 중복시킨다.

### 방법

- 내부에서 외부로 변화시키는 방법이란
- 내부에서 외부로의 변화란 내부의 표현 양식을 변경한 후 외부 인터페이스를 변화시키는 방법을 말한다.
    1. 새로운 포맷의 인스턴스 변수를 추가한다.
    2. 기존 포맷의 인스턴스 변수를 세팅하는 모든 부분에서 새로운 인스턴스 변수도 세팅하게 만든다.
    3. 기존 변수를 사용하는 모든 곳에서 새 변수를 사용하게 만든다.
    4. 기존 포맷을 제거한다.
    5. 새 포맷에 맞게 외부 인터페이스를 변경한다.
- API를 먼저 변화시키기를 원할 때
    1. 새 포맷으로 인자를 하나 추가한다.
    2. 새 포맷 인자에서 이전 포맷의 내부적인 표현양식으로 번역한다.
    3. 이전 포맷 인자를 삭제한다.
    4. 이전 포맷을 사용하는 것들을 새 포맷으로 바꾼다.
    5. 이전 포맷을 지운다.

## 메소드 추출하기

- 길고 복잡한 메소드를 읽기 쉽게 만들려면 어떻게 할까?
- 긴 메소드의 일부분을 별도의 메소도로 분리해내고 이를 호출하게 한다.

### 방법

1. 기존의 메소드에서 별도의 메소드로 분리할 수 있을만한 부분을 찾아낸다. 반복문 내부의 코드나 반복문 전체, 혹은 조건문의 가지들이 일반적인 후보다.
2. 추출할 여역의 외부에서 선언된 임시 변수에 대해 할당하는 문장이 없는지 확인한다.
3. 추출할 코드를 복사해서 새 코드에 붙인다.
4. 원래 메소드에 있던 각각의 임시 변수와 매개 변수 중 새 메소드에서도 쓰이는 게 있으면, 이들을 새 메소드의 매개 변수로 추가한다.
5. 기존의 메소드에서 새 메소드를 호출한다.

## 메소드 인라인

- 너무 꼬여있거나 산재한 제어 흐름을 단순화하려면 어떻게 할까?
- 메소드를 호출하는 부분을 호출도리 메소드의 본문으로 교체한다.

### 방법

1. 메소드를 복사한다.
2. 메소드 호출하는 부분을 지우고 복사한 코드를 붙인다.
3. 모든 형식(formal) 매개 변수를 실제(actual) 매개 변수로 변경한다. 예를 들어 만약 reader.getNext() 같은 매개 변수를 전달했다면, 이를 지역 변수에 할당해주어야 할 것이다(위의 표현
   식은 reader의 내부 상태를 바꾸기 때문에)

## 인터페이스 추출하기

- 자바 오퍼레이션에 대한 두 번째 구현을 추가하려면 어떻게 해야 할까?
- 공통되는 오퍼레이션을 담고 있는 인터페이스를 만들면 된다.

### 방법

1. 인터페이스를 선언한다. 때론 새로 추가될 인터페이스의 이름으로 기존 클래스의 이름을 사용해야 하는 경우가 있는데,
   그런 경우라면 인터페이스를 추가하기 전에 기존 클래스의 이름을 변경해주어야 한다.
2. 기존 클래스가 인터페이스를 구현하도록 만든다.
3. 필요한 메소드를 인터페이스에 추가한다. 필요하다면 클래스에 존재하는 메소드들의 가시성을 높여준다.
4. 가능한 모든 곳의 타입 선어부에서 클래스 이름 대신 인터페이스 이름을 사용하게 바꾼다.

## 메소드 옮기기

- 메소드를 원래 있어야 할 장소로 옮기려면 어떻게 해야 할까?
- 어울리는 클래스에 메소드를 추가해주고, 그것을 호출하게 하라.

### 방법

1. 메소드를 복사한다.
2. 원하는 클래스에 붙이고 이름을 적절히 지어준 다음 컴파일한다.
3. 원래 객체가 메소드 내부에서 참조된다면, 원래 객체를 새 메소드의 매개 변수로 추가한다.
   원래 객체의 필드들이 참조되고 있다면 그것들로 매개 변수로 추가한다.
   만약 원래 객체의 필드들이 갱신된다면 포기해야 한다.
4. 원래 메소드의 본체를 지우고, 그곳에 새 메소드를 호출하는 코드를 넣는다.

## 메소드 객체

- 여러 개의 매개 변수와 지역 변수를 갖는 복잡한 메소드를 어떻게 표현할까?
- 메소드를 꺼내서 객체로 만든다.

### 방법

1. 메소드와 같은 매개 변수를 갖는 객체를 만든다.
2. 메소드의 지역 변수를 객체의 인스턴스 변수로 만든다.
3. 원래 멘소드와 동일한 내용을 갖는 run()이라는 이름의 메소드를 만든다.
4. 원래 메소드에서 새로 만들어진 클래스의 인스턴스를 생성하고 run()을 호출한다.

## 매개 변수 추가

- 메소드에 매개 변수를 추가하려면?

### 방법

1. 메소드가 인터페이스에 선언되어 있다면 일단 인터페이스에 매개 변수를 추가한다.
2. 매개 변수를 추가한다.
3. 컴파일 에러가 여러분에게 어딜 고쳐야 하는지 알려줄 것이다. 이것을 이용하라.

## 메소드 매개 변수를 생정자 매개 변수로 바꾸기

- 하나 이상의 메소드의 매개 변수를 생성자로 옮기려면 어떻게 할까?

### 방법

1. 생성자에 매개 변수를 추가한다.
2. 매개 변수와 같은 이름을 갖는 인스턴스 변수를 추가한다.
3. 생성자에서 인스턴스 변수의 값을 설정한다.
4. 'parameter'를 'this.parameter'로 하나씩 찾아 바꾼다.
5. 매개 변수에 대한 참조가 더 이상 존재하지 않으면 해당 매개 변수를 메소드와 모든 호출자에서 제거한다.
6. 이제 필요 없어진 'this.'를 제거 한다.
7. 변수명을 적절히 변경한다.