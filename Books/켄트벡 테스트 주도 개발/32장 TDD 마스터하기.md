# TDD 마스터하기

- 리팩토링 초기에는 아주 작은 단계로 작업할 준비가 되어 있어야 한다.
- 수작업 리팩토링은 에러가 발생하기 쉬운데, 그렇게 해서 더 많은 실수를 하고 그럼 나중에야 잡게 된다면 결국 당신은 리팩토링을 점점 덜 하게 될 것이다.
- 매우 작은 단계로 수작업 리팩토링을 20번 하고 나면, 몇 단계 건너 뛰는 실험을 해보라.
- 자동화된 리팩토링 툴은 리팩토링을 엄청나게 가속화시킨다.
- 20번의 단계를 통해 해야 할 일이 메뉴 아이템 하나로 간단히 해결된다.
- 훌륭한 툴의 지원이 있다는 걸 알고 있다면 코드가 어떤 구조를 갖추길 원하는지 보기 위해 여러 가지 실험을 시도하면서 리팩토링에 훨씬 적극적이게 될 것이다.

## 테스트할 필요가 없는 것은 무엇인가?

- 플립(Phlip)이 알려준 간단한 대답은 이렇다.
- "두려움이 지루함으로 변할 때까지 테스트를 만들어라."
- 당신이 작성하는 것들에 대해서만 테스트해라.
- 불신할 이유가 없ㄱ다면 다른 사람이 만든 코드를 테스트하지 마라.

## 좋은 테스트를 갖췄는지의 여부를 어떻게 알 수 있는가?

- 긴 셋업 코드: 하나의 단순한 단언을 수행하기 위해 수백 줄의 객체 생성 코드가 필요하다면 뭔가 문제가 있는 거다. 객체가 너무 크다는 뜻이므로 나뉠 필요가 있다.
- 셋업 중복: 공통의 셋업 코드를 넣어 둘 공통의 장소를 찾기 힘들다면, 서로 밀접하게 엉킨 객체들이 너무 많다는 뜻이다.
- 실행 시간이 오래 걸리는 테스트: 실행하는 데 오래 걸리면 테스트를 자주 실행하지 않게 되고, 한동안 실행이 안 된 채로 남게 되는 경우가 종종 있고, 이렇게 되면 테스트가 아예 동작하지 않을 수도 있다. 테스트의 실행 시간이 길다는 것이 애플리케이션의 작은 부분만 따로 테스트하기가 힘들다는 것을 의미한다.
- 깨지기 쉬운 테스트: 예상치 못하게 실패하는 테스트가 있다면 이는 애플리케이션의 특정 부분이 다른 부분에 이상한 방법으로 영향을 끼친다는 뜻이다. 연결을 끊거나 두 부분을 합하는 것을 통해 멀리 떨어진 것의 영향력이 없어지도록 설계해야 한다.

## TDD로 프레임워크를 만들려면 어떻게 해야 하나?

- 모순: 코드의 미래에 대해 고려하지 않음으로 인해, 코드가 더 뛰어난 적응성을 가질 수 있게 한다.
- "오늘을 위해 코딩하고, 내일을 위해 설계하라."
- TDD는 이것을 뒤집은 것처럼 보인다.
- "내일을 위해 코딩하고, 오늘을 위해 설계하라."
- 그래서 실제로 벌어지는 일은 어떤가?
  - 첫 번째 기능을 구현한다. 직관적으로 구현되고, 따라서 짧은 시간안에 결함도 적은 상태로 완성된다.
  - 첫 번째 기능에 대한 변주가 되는 두 번째 기능을 구현한다. 두 기능 사이의 중복이 한 곳으로 모이고, 서로 다른 부분은 다른 곳(다른 메소드나 심지어는 다른 클래스)으로 옮겨진다.
  - 앞의 두 기능에 대한 변주로 세 번째 기능을 구현한다. 공통의 로직은 약간의 수정만을 통해 재활용 가능한 상태로 만들어질 수 있을 것이다. 그리고 공통적이지 않은 로직들도 다른 메소드 혹은 클래스 등 명확하게 로직이 있어야 할 곳에 있게 되는 경향이 있다.
- 개방-폐쇄 원칙은 서서히 지켜져 가는데, 실제로 발생하는 변주들에 대해서 특히 더 그렇다.
- 테스트 주도 개발은 비록 발생하지 않은(혹은 아직 발생하지 않은) 변주 종류는 잘 표현하지 못할지라도.
- 발생하는 변주 종류들, 바로 그것들을 잘 표현하는 프레임워크를 만들게 해 준다.

## 피드백이 얼마나 필요한가?

- 테스트를 얼마나 작성해야 하나? 작은 예제를 풀어보자.
- 삼각형의 각 변의 길이를 나타내는 세 개의 정수를 받아서 다음 값을 반환하는 문제다.
  - 정삼각형이면 1
  - 이등변삼각형이면 2
  - 부등변삼각형이면 3
  - 제대로 된 삼각형이 아니면 예뢰를 던진다.
- 당신은 자신의 경험과 숙고를 통해, 얼마나 많은 테스틀르 작성할지 결정해야 할 것이다.
- 나는 테스트를 얼마나 작성할지 고려할 때, 실패간 평균시간을 생각한다.
- TDD의 테스트에 대한 관점은 실용적이다.
- TDD에서 테스트는 어떤 목적을 위한 하나의 수단이다(여기서 목적은 우리가 깊이 신뢰할 수 있는 코드가 되겠다).
- 만약 어떤 구현에 대한 지식이 신뢰할 만 하다면 그에 대한 테스트는 작성하지 않을 것이다.

## 테스트를 지워야 할 때는 언제인가?

- 테스트가 많으면 좋기야 하지만, 서로 겹치는 두 개의 테스트가 있어도 이들을 남겨두어야 하는가?
- 대답은 두 가지 기준에 의해서 결정된다.
  - 첫째 기준은 자신감이다. 테스트를 삭제할 경우 자신감이 줄어들 것 같으면 절대 테스트를 지우지 말아야 한다.
  - 둘째 기준은 커뮤니케이션이다. 두 개의 테스트가 코드의 동일한 부분을 실행하더라도, 이 둘이 서로 다른 시나리오를 말한다면 그대로 남겨두어야 한다.
- 자신감이나 커뮤니케이션 면에서 별 부가적인 이득이 없는 중복된 테스트가 두 개 있다면, 덜 유용한 것을 삭제하라.

## 프로그래밍 언어나 환경이 TDD에 어떤 영향을 주는가?

- TDD 주기(테스트/컴파일/실행/리팩토링)를 수행하기가 힘든 언어나 환경에서 작업하게 되면 단계가 커지는 경향이 있다.
  - 각 테스트가 더 많은 부분을 포함하게 만든다.
  - 중간 단계를 덜 거치고 리팩토링을 한다.
- 이렇게 하면 개발 속도가 더 빨라질까, 느려질까?
- TDD 주기를 더 잘 지워하는 언어와 환경에서 작업하게 되면 더 많은 실험을 해보려고 할 것이다.
- 이것이 당신이 더 빨리 진행하도록 혹은 더 나은 해법에 도달하도록 도와주는가,
- 아니면 순수한 숙고(리뷰나 <sup>[[1]](#literate-program)</sup>문학적 프로그래밍을 위해 일정 시간을 제도화하는 것)이 더 나을까?

## 거대한 시스템을 개발할 때에도 TDD를 할 수 있는가?

- 극닥적으로 큰 시스템에도 TDD를 적용할 수 있는가? 어떤 새로운 종류의 테스트를 만들어야 하는가? 어떤 새로운 종류의 리팩토링이 필요한가?
- 시스템에 있는 기능의 양은 TDD의 효율에 영향을 미치지 않는 것 같다.
- 중복을 제거함에 따라 더 작은 객체들이 만들어지게 되고, 이 작은 객체들은 애플리케이션의 크기와 무관하게 독립적으로 테스트될 수 있다.

## 애플리케이션 수준의 테스트로도 개발을 주도할 수 있는가?

- 작은 규모의 테스트로 개발을 주도하는 것의 문제는 실제로 사용자가 원하지 않는데 그들이 원할 거라 생각하고 구현할 수도 있는 위험을 끄록 간다는 점에 있다.
- 애플리케이션 수준에서 테스트를 작성한다면 어떨까?
- 그렇게 된다면 프로그래머에게 약간의 도움을 받아서 사용자가 직접 원하는 바를 테스트로 작성할 수 있을 것이다.
- 아직 만들지 않은 기능에 대한 테스트를 어떻게 작성하고 실행할 것인가?
- 이 문제에서 탈출하는 방법이 어떻게든 있는 것 같다.
- 전형적인 방법은 아직 어떻게 해석해야 할지 모르는 테스트를 만났을 때 우아하게 에러를 뱉어내는 해석기(interpreter)를 도입하는 것이다.
- 애플리케이션 테스트 주도 개발(ATDD, Application Test-Driven Development)에는 사회적인 문제도 존재한다.
- 테스트를 작성하는 것은 사용자(여기서 사용자란 사용자들을 포함하는 팀을 말한다)에게는 기존에 없던 새로운 책임이 되는 것이다.
- 조직은 이런 종류의 책임 이동에 저항한다.
- 애플리케이션 테스트를 우선적으로 작성하기 위해서는 협조 노력(콘서트에서 많은 사람이 호흡을 맞추는 것과 같은 노력)이 필요하다
- ATDD의 또 다른 문제는 테스트와 피드백 사이의 길이다.
- 만약 고객이 테스트를 만들고 그 테스트가 통과하길 기다리는 동안 열흘이 걸린다면 거의 대부분이 시간을 빨간 막대를 보며 지내게 될 것이다.
- 내 생각에 난 앞으로도 프로그래머 수준의 TDD를 원할 것 같다. 그래서
  - 즉시 초록 막대를 볼 수 있고
  - 내부 설계를 단순화할 수 있도록 할 수 있길 원한다.

## 프로젝트 중반에 TDD를 도입하려면 어떻게 해야 할까?

- 어느 정도 작동하는 코드가 상당량 있다. 새 코드는 TDD로 작업하길 원한다. 어떠헥 해야 할까?
- 가장 큰 문제는 테스트를 염두에 두지 않고 만든 코드는 테스트하기가 그리 쉽지 않다는 점이다.
- 일부분만을 격리해서 실행하고 결과를 검사할 쑤 있게끔 인터페이스가 설계되어 있지 않다.
- "고치면 되잖아."하고 말할 수도 있을 것이다.
- 하지만 리팩토링 과정에 에러를 만들 수도 있는데, 아직 테스트가 없기 때문에 에러가 생겼다는 점을 알아낼 수 없을 것이다.
- 확실히 하지 말아야 할 일이 있는데, 그것은 코드 전체를 위한 테스트를 한꺼번에 다 만들고, 코드 전체를 한 번에 리팩토링하는 일이다.
- 이런 작업은 몇 달이나 걸릴 텐데, 그 몇 달 동안 아무런 새로운 기능도 추가로 구현하지 못할 것이다.
- 수입 없는 지출은 일반적으로 지속 가능한 프로세스가 아니다. 따라서 우선 해야 할 일은 변경의 범위를 제한하는 것이다.
- 지금 당장 변할 필요가 없는 부분을 봤다면, 그냥 그대로 놔둘 것이다. 과거의 잘못에 대해 눈물을 흘릴지도 모르지만 일단 그대로 놔둔다.
- 다음로 해야 할 일은 테스트와 리팩토링 사이에 존재하는 교착상태를 풀어주는 것이다.
- 테스트가 아닌 다른 방법으로도 피드백을 얻을 수 있는데, 아주 조심스럽게 작업하는 방법이나 파트너와 함께 작업하는 방법 등이 그런 것들이다.
- 우리는 전체적인 레벨에서 피드백을 얻을 수 있는데, 이것은 충분하지는 않지만 어느 정도의 확신을 주는 시스템 레벨의 테스트와 비슷하다.
- 이 피드백을 이용해, 우리가 바꾸어야 하는 부분이 변화에 좀더 수용적이 되도록 할 수 있다.
- 시간이 지나면서, 시스템에서 늘 벼노하하는 부분들ㄹ은 테스트 주도로 된 것처럼 보이게 될 것이다.

## TDD는 누구를 위한 것인가?


<br>

---

<p id="literate-program">1. 문학적 프로그래밍: 문학적 프로그램(literate program)은 도널드 크누스가 제창한 개념으로 프로그램과 문서를 엮어서 하나가 되게 하는 것을 말한다.</p>