# TDD 마스터하기

- 리팩토링 초기에는 아주 작은 단계로 작업할 준비가 되어 있어야 한다.
- 수작업 리팩토링은 에러가 발생하기 쉬운데, 그렇게 해서 더 많은 실수를 하고 그럼 나중에야 잡게 된다면 결국 당신은 리팩토링을 점점 덜 하게 될 것이다.
- 매우 작은 단계로 수작업 리팩토링을 20번 하고 나면, 몇 단계 건너 뛰는 실험을 해보라.
- 자동화된 리팩토링 툴은 리팩토링을 엄청나게 가속화시킨다.
- 20번의 단계를 통해 해야 할 일이 메뉴 아이템 하나로 간단히 해결된다.
- 훌륭한 툴의 지원이 있다는 걸 알고 있다면 코드가 어떤 구조를 갖추길 원하는지 보기 위해 여러 가지 실험을 시도하면서 리팩토링에 훨씬 적극적이게 될 것이다.

## 테스트할 필요가 없는 것은 무엇인가?

- 플립(Phlip)이 알려준 간단한 대답은 이렇다.
- "두려움이 지루함으로 변할 때까지 테스트를 만들어라."
- 당신이 작성하는 것들에 대해서만 테스트해라.
- 불신할 이유가 없ㄱ다면 다른 사람이 만든 코드를 테스트하지 마라.

## 좋은 테스트를 갖췄는지의 여부를 어떻게 알 수 있는가?

- 긴 셋업 코드: 하나의 단순한 단언을 수행하기 위해 수백 줄의 객체 생성 코드가 필요하다면 뭔가 문제가 있는 거다. 객체가 너무 크다는 뜻이므로 나뉠 필요가 있다.
- 셋업 중복: 공통의 셋업 코드를 넣어 둘 공통의 장소를 찾기 힘들다면, 서로 밀접하게 엉킨 객체들이 너무 많다는 뜻이다.
- 실행 시간이 오래 걸리는 테스트: 실행하는 데 오래 걸리면 테스트를 자주 실행하지 않게 되고, 한동안 실행이 안 된 채로 남게 되는 경우가 종종 있고, 이렇게 되면 테스트가 아예 동작하지 않을 수도 있다.
  테스트의 실행 시간이 길다는 것이 애플리케이션의 작은 부분만 따로 테스트하기가 힘들다는 것을 의미한다.
- 깨지기 쉬운 테스트: 예상치 못하게 실패하는 테스트가 있다면 이는 애플리케이션의 특정 부분이 다른 부분에 이상한 방법으로 영향을 끼친다는 뜻이다. 연결을 끊거나 두 부분을 합하는 것을 통해 멀리 떨어진 것의
  영향력이 없어지도록 설계해야 한다.

## TDD로 프레임워크를 만들려면 어떻게 해야 하나?

- 모순: 코드의 미래에 대해 고려하지 않음으로 인해, 코드가 더 뛰어난 적응성을 가질 수 있게 한다.
- "오늘을 위해 코딩하고, 내일을 위해 설계하라."
- TDD는 이것을 뒤집은 것처럼 보인다.
- "내일을 위해 코딩하고, 오늘을 위해 설계하라."
- 그래서 실제로 벌어지는 일은 어떤가?
    - 첫 번째 기능을 구현한다. 직관적으로 구현되고, 따라서 짧은 시간안에 결함도 적은 상태로 완성된다.
    - 첫 번째 기능에 대한 변주가 되는 두 번째 기능을 구현한다. 두 기능 사이의 중복이 한 곳으로 모이고, 서로 다른 부분은 다른 곳(다른 메소드나 심지어는 다른 클래스)으로 옮겨진다.
    - 앞의 두 기능에 대한 변주로 세 번째 기능을 구현한다. 공통의 로직은 약간의 수정만을 통해 재활용 가능한 상태로 만들어질 수 있을 것이다. 그리고 공통적이지 않은 로직들도 다른 메소드 혹은 클래스 등
      명확하게 로직이 있어야 할 곳에 있게 되는 경향이 있다.
- 개방-폐쇄 원칙은 서서히 지켜져 가는데, 실제로 발생하는 변주들에 대해서 특히 더 그렇다.
- 테스트 주도 개발은 비록 발생하지 않은(혹은 아직 발생하지 않은) 변주 종류는 잘 표현하지 못할지라도.
- 발생하는 변주 종류들, 바로 그것들을 잘 표현하는 프레임워크를 만들게 해 준다.

## 피드백이 얼마나 필요한가?

- 테스트를 얼마나 작성해야 하나? 작은 예제를 풀어보자.
- 삼각형의 각 변의 길이를 나타내는 세 개의 정수를 받아서 다음 값을 반환하는 문제다.
    - 정삼각형이면 1
    - 이등변삼각형이면 2
    - 부등변삼각형이면 3
    - 제대로 된 삼각형이 아니면 예뢰를 던진다.
- 당신은 자신의 경험과 숙고를 통해, 얼마나 많은 테스틀르 작성할지 결정해야 할 것이다.
- 나는 테스트를 얼마나 작성할지 고려할 때, 실패간 평균시간을 생각한다.
- TDD의 테스트에 대한 관점은 실용적이다.
- TDD에서 테스트는 어떤 목적을 위한 하나의 수단이다(여기서 목적은 우리가 깊이 신뢰할 수 있는 코드가 되겠다).
- 만약 어떤 구현에 대한 지식이 신뢰할 만 하다면 그에 대한 테스트는 작성하지 않을 것이다.

## 테스트를 지워야 할 때는 언제인가?

- 테스트가 많으면 좋기야 하지만, 서로 겹치는 두 개의 테스트가 있어도 이들을 남겨두어야 하는가?
- 대답은 두 가지 기준에 의해서 결정된다.
    - 첫째 기준은 자신감이다. 테스트를 삭제할 경우 자신감이 줄어들 것 같으면 절대 테스트를 지우지 말아야 한다.
    - 둘째 기준은 커뮤니케이션이다. 두 개의 테스트가 코드의 동일한 부분을 실행하더라도, 이 둘이 서로 다른 시나리오를 말한다면 그대로 남겨두어야 한다.
- 자신감이나 커뮤니케이션 면에서 별 부가적인 이득이 없는 중복된 테스트가 두 개 있다면, 덜 유용한 것을 삭제하라.

## 프로그래밍 언어나 환경이 TDD에 어떤 영향을 주는가?

- TDD 주기(테스트/컴파일/실행/리팩토링)를 수행하기가 힘든 언어나 환경에서 작업하게 되면 단계가 커지는 경향이 있다.
    - 각 테스트가 더 많은 부분을 포함하게 만든다.
    - 중간 단계를 덜 거치고 리팩토링을 한다.
- 이렇게 하면 개발 속도가 더 빨라질까, 느려질까?
- TDD 주기를 더 잘 지워하는 언어와 환경에서 작업하게 되면 더 많은 실험을 해보려고 할 것이다.
- 이것이 당신이 더 빨리 진행하도록 혹은 더 나은 해법에 도달하도록 도와주는가,
- 아니면 순수한 숙고(리뷰나 <sup>[[1]](#literate-program)</sup>문학적 프로그래밍을 위해 일정 시간을 제도화하는 것)이 더 나을까?

## 거대한 시스템을 개발할 때에도 TDD를 할 수 있는가?

- 극닥적으로 큰 시스템에도 TDD를 적용할 수 있는가? 어떤 새로운 종류의 테스트를 만들어야 하는가? 어떤 새로운 종류의 리팩토링이 필요한가?
- 시스템에 있는 기능의 양은 TDD의 효율에 영향을 미치지 않는 것 같다.
- 중복을 제거함에 따라 더 작은 객체들이 만들어지게 되고, 이 작은 객체들은 애플리케이션의 크기와 무관하게 독립적으로 테스트될 수 있다.

## 애플리케이션 수준의 테스트로도 개발을 주도할 수 있는가?

- 작은 규모의 테스트로 개발을 주도하는 것의 문제는 실제로 사용자가 원하지 않는데 그들이 원할 거라 생각하고 구현할 수도 있는 위험을 끄록 간다는 점에 있다.
- 애플리케이션 수준에서 테스트를 작성한다면 어떨까?
- 그렇게 된다면 프로그래머에게 약간의 도움을 받아서 사용자가 직접 원하는 바를 테스트로 작성할 수 있을 것이다.
- 아직 만들지 않은 기능에 대한 테스트를 어떻게 작성하고 실행할 것인가?
- 이 문제에서 탈출하는 방법이 어떻게든 있는 것 같다.
- 전형적인 방법은 아직 어떻게 해석해야 할지 모르는 테스트를 만났을 때 우아하게 에러를 뱉어내는 해석기(interpreter)를 도입하는 것이다.
- 애플리케이션 테스트 주도 개발(ATDD, Application Test-Driven Development)에는 사회적인 문제도 존재한다.
- 테스트를 작성하는 것은 사용자(여기서 사용자란 사용자들을 포함하는 팀을 말한다)에게는 기존에 없던 새로운 책임이 되는 것이다.
- 조직은 이런 종류의 책임 이동에 저항한다.
- 애플리케이션 테스트를 우선적으로 작성하기 위해서는 협조 노력(콘서트에서 많은 사람이 호흡을 맞추는 것과 같은 노력)이 필요하다
- ATDD의 또 다른 문제는 테스트와 피드백 사이의 길이다.
- 만약 고객이 테스트를 만들고 그 테스트가 통과하길 기다리는 동안 열흘이 걸린다면 거의 대부분이 시간을 빨간 막대를 보며 지내게 될 것이다.
- 내 생각에 난 앞으로도 프로그래머 수준의 TDD를 원할 것 같다. 그래서
    - 즉시 초록 막대를 볼 수 있고
    - 내부 설계를 단순화할 수 있도록 할 수 있길 원한다.

## 프로젝트 중반에 TDD를 도입하려면 어떻게 해야 할까?

- 어느 정도 작동하는 코드가 상당량 있다. 새 코드는 TDD로 작업하길 원한다. 어떠헥 해야 할까?
- 가장 큰 문제는 테스트를 염두에 두지 않고 만든 코드는 테스트하기가 그리 쉽지 않다는 점이다.
- 일부분만을 격리해서 실행하고 결과를 검사할 쑤 있게끔 인터페이스가 설계되어 있지 않다.
- "고치면 되잖아."하고 말할 수도 있을 것이다.
- 하지만 리팩토링 과정에 에러를 만들 수도 있는데, 아직 테스트가 없기 때문에 에러가 생겼다는 점을 알아낼 수 없을 것이다.
- 확실히 하지 말아야 할 일이 있는데, 그것은 코드 전체를 위한 테스트를 한꺼번에 다 만들고, 코드 전체를 한 번에 리팩토링하는 일이다.
- 이런 작업은 몇 달이나 걸릴 텐데, 그 몇 달 동안 아무런 새로운 기능도 추가로 구현하지 못할 것이다.
- 수입 없는 지출은 일반적으로 지속 가능한 프로세스가 아니다. 따라서 우선 해야 할 일은 변경의 범위를 제한하는 것이다.
- 지금 당장 변할 필요가 없는 부분을 봤다면, 그냥 그대로 놔둘 것이다. 과거의 잘못에 대해 눈물을 흘릴지도 모르지만 일단 그대로 놔둔다.
- 다음로 해야 할 일은 테스트와 리팩토링 사이에 존재하는 교착상태를 풀어주는 것이다.
- 테스트가 아닌 다른 방법으로도 피드백을 얻을 수 있는데, 아주 조심스럽게 작업하는 방법이나 파트너와 함께 작업하는 방법 등이 그런 것들이다.
- 우리는 전체적인 레벨에서 피드백을 얻을 수 있는데, 이것은 충분하지는 않지만 어느 정도의 확신을 주는 시스템 레벨의 테스트와 비슷하다.
- 이 피드백을 이용해, 우리가 바꾸어야 하는 부분이 변화에 좀더 수용적이 되도록 할 수 있다.
- 시간이 지나면서, 시스템에서 늘 벼노하하는 부분들ㄹ은 테스트 주도로 된 것처럼 보이게 될 것이다.

## TDD는 누구를 위한 것인가?

- 만약 당신이 어느 정도는 작동하는 코드를 왕창 입력해 넣는 것에 행복해 하고,
- 그 결과를 두 번 다시 쳐다보지 않는 것에 행복해 한다면,
- TDD는 당신을 위한 것이 아니다.
- TDD는 더 나은 코드를 작성한다면 좀더 성공할 것이라는, 매력정일 정도로 나이브하며 해커적인 가정에 근거한다.
- TDD는 더 깔끔한 설계를 할 수 있도록, 그리고 더 많은 것을 배워감에 따라 설계를 더 개선할 수 있도록,
- 적절한 때 적절한 문제에 집중할 수 있게끔 도와준다.
- 엄청난 흥미를 가지고 새 프로젝트를 시작해서는 시간이 지남에 따라 서서히 코드가 썩어가는 걸 보게 된다.
- 일년쯤 지나면 하루라도 빨리 냄새 나는 코드를 던져버리고 다음 프로젝트가 시작되기만을 기다리는 것이다.
- TDD는 시간이 지남에 따라 코드에 대한 자신감을 점점 더 쌓아갈 수 있게 해준다.
- 테스트가 쌓여감에 따라(그리고 여러분의 테스팅 기술이 늘어감에 따라) 시스템의ㅏ 행위에 대한 자신감을 더 많이 얻게 된다.
- 설계를 개선해 낙마에 따라 점점 더 많은 설계 변경이 가능해진다.
- 나의 목적은 처음 반짞이는 눈빛으로 프로젝트를 시작할 때보다 프로젝트를 시작하고 1년이 지난 후에 더 좋은 느낌을 갖게 되는 것인데,
- TDD가 이 목적을 달성할 수 있도록 도와준다.

## TDD는 초기 조건에 민감한가?

- 테스트를 취할 때 특정한 순서로 하면 매우 매끄럽게 잘 넘어가는 것 같다.
- 테스트를 특정 순서로 구현하는 것이 다른 순서에 비해 수십배 더 빠르다/쉽다는 것이 정말 사실인가?
- 단지 내 구현 기술이 부족해서 그런 것은 아닐까? 혹 테스트를 특정 순서로 공략해야 한다는 것을 넌지시 알려주는 무언가가 테스트 속에 있는 건 아닐까?
- 만약 TDD가 작은 차원에서 초기 조건에 민감하다면, 큰 차원에서는 예측 가능할까?
- (미시시피강의 작은 소용돌이들은 예측 불가능하지만, 강 어귀에서 대략 초당 2,000,000세제곱 피트 정도의 물이 흐른다는 것은 믿을 수 있다.)

## TDD와 패턴의 관계는?

- 반복적 행동을 규칙으로 환원함으로써 규칙을 적요하는 것은 기계적이며 단순 암기가 된다는 점이다.
- 이것은 언제나 최초 원리에서 시작해서 모든 것을 다시 논구하는 거솝다 더 빠르다.
- 예외 혹은 규칙의 어느 것도 들어맞지 않는 문제가 있을 경우,
- 새로운 것을 창조하고 적용할 더 많은 시간과 에너지를 갖게 된다.
- 어떤 작업을 수행하기 위해 스트래티지 패턴을 사용하기로 결정했다고 치자.
- 첫 번째 변화를 위한 테스트를 자것ㅇ하고 이를 메소드로 구현한다.
- 그 다음 리팩토링 단계에서 자연스럽게 스트래티지 패턴이 나탈날 수 있도록 하기 위해 의식적으로 두 번째 테스트를 작성한다.
- 그냥 시스템이 무슨일을 할지 생각하고 나중에 설계가 알아서 정해지도록 하는 것이 더 낫다.

## 어째서 TDD가 잘 작동하는가?

- 결함을 빨리 발견해 고칠수록 비용은 낮아진다. 가끔은 엄청나게 낮아지기도 한다(마스 렌더에 대해서 찾아보기 바란다).
- 결함감소에서 오는 이차적 심리학적, 사회적 효과가 무척 많다.
- 나는 TDD를 시작한 이후로 스트레스를 훨씬 적게 받게 됐다.
- 모든 것에 대해 한꺼번에 걱정할 필요가 없게 됐다.
- 나는 직면한 테스트 하나를 실행하게 할 수 있고, 그 뒤엔 나머지를 전부 실행할 수도 있다. 팀원들과의 관계도 더 긍정적으로 변했다.
- 새로 릴리즈한 시스템은 이제 더 이상 새로운 버그의 근원지가 아니고, 단지 새로운 기능만을 더 제공하게 되었다.
- TDD의 또 다른 효과는 설계 결정에 대한 피드백 고리를 단축시킨다는 점이다.
- 하루에도 수십에서 수백 번씩 테스트하면서 구현에 대한 피드백고리는 확실히 짧아졌다.
- 고작 수 초에서 수 분 사이일 뿐이다. 설계 결정에 대한 피드백 루프의 길이느 설계에 대한 생각(API가 이런 식으로 생기며 좋겠다, 혹은 메타포가 이래야 할 것이다 등)과 그에 대한 첫 번째 예제(그 생각을
  담고 있는 테스트 작성) 사이의 간격이다.

<br>

## 이름을 테스트 주도 개발이라고 한 이유는?

- 개발: 여기에서 '개발(development)'이란 분석, 논리적, 설계, 물리적 설계, 구현, 테스팅, 검토, 통합, 배포를 아우르는 복잡한 춤을 말한다.
- 주도: 만약 테스트로 주도하지 않는다면, 무엇으로 주도할 것인가? 추측으로? 아니면 명세로? (이 두 단어가 동일한 어원을 갖는다 사실을 아는가?)
- 테스트: 자동화되고 구체적이며 명확한 테스트를 말한다. 버튼을 누르면 테스트가 실행된다. TDD의 아이러니 중 하나는 TDD가 테스트 기술이 아니라는 점이다. TDD는 분석 기술이며, 설계 기술이기도 하다.
  사실은 개발의 모든 활동을 구조화하는 기술이다.

## TDD와 익스트림 프로그래밍 실천법 사이에 어떤 관련이 있는가?

- 짝프로그래밍
  - TDD를 하면서 작성하게 되는 테스트는 짝 프로그래밍 과정에서 뛰어난 의사소통 수단이 된다.
  - 짝 프로그래밍을 할 때 풀고 있는 문제에 대해 파트너가 여러분 의견에 동의하지 않는 경우가 있는데, 이는 반드시 피해야 할 문제다.
  - 말도 안 되는 소리 같지만 항상 벌어지는 일이다. 특히 짞 프로그래밍을 처음 배우는 경우엔 더욱 빈번하다.
  - 짝으로 ㅇ리하는 것은 TDD를 강화하는데, 당신이 지칠 때 머릿속에 활기를 되찾게 해주기 떄문이다.
  - TDD의 리듬 때문에 완전히 몰입할 수 있는데, 그렇게 되면 지친 상태에서도 계속 프로그래밍하기도 한다.
  - 하지만 짝 프로그래밍을 한다면 여러분이 지칠 때 파트너가 키보드를 받아줄 것이다.
- 활기차게 일하기
  - XP에서는 기운이 있을 때 일을 시작해서 지치면 그만할 것을 권유한다.
  - 다음 테스트를 통과시키지 못하겠거나, 어떤 테스트 두 개를 동시에 통과하도록 만들 방법을 모르겠다면,
  - 잠시 쉴 시간이다.
- 지속적인 통합
  - 테스트는 좀더 자주 통합할 수 있게 해주기 때문에 아주 훌륭한 자원이 된다.
  - 새로운 테스트를 통과시킨 후 주옵ㄱ을 제거했다면 체크인한다.
  - 그렇게 되면 체크인 간격이 1~2시간에서 내가 보통 노리는 15~30분 정도로 단축된다.
  - 이 방법이야말로 많은 프로그래머들로 구성된 큰 팀에서 동일한 코드 베이스를 사용할 수 있게 하는 핵심 중 하나다
  - "n이 항상 1이면, n<sup>2</sup> 문제는 더 이상 문제가 아니다"
- 단순 설계
  - 테스트를 통과하기 위해 필요한 만큼만 코딩하고 모든 중복을 제거한다면,
  - 여러분은 자동으로 현재까지의 요구사항에 딱 들어맞는 설계를 얻게 될 것이고,
  - 이 설계는 앞으로의 어떠한 사용자 스토리(user story)에 대해서도 동등하게 준비된 상태일 것이다.
  - 현재 시스템에 대한 완벽한 아ㅣ텍처를 위해 더도 덜도 말고 딱 맞는 설계를 찾는 사고방식으로 테스트 작성은 더 쉬워진다.


---

<p id="literate-program">1. 문학적 프로그래밍: 문학적 프로그램(literate program)은 도널드 크누스가 제창한 개념으로 프로그램과 문서를 엮어서 하나가 되게 하는 것을 말한다.</p>