# 객체지향 vs 절차지향
## 도메인
- 개발에 필요한 범위로 좁혀 뽑아낸 구현 대상

## 도메인 모델
- 도메인을 잘 추상화한 것

## 온라인 영화 에매 시스템
- 영화
  - 메타정보성
- 상영
  - 예매하는 대상이 사용하는것을 상영이라고 함
- 할인정책
  - 금액할인정책
  - 퍼센트할인정책
- 할인조건
  - 조건이 만족했을떄 할인정책 적용
  - 회차 조건
  - 시간 조건
- 할인정책 + 할인조건 으로 할인정책을 설정할 수 있음
- 하나의 영화는 하나의 할인 정책을 설정할 수 있음
- 할인 정책에는 여러개의 할인 조건을 설정할 수 있음

## 절차적인 설계
- 결과물은 중요하지 않다 어떤 생각을 가지고 구현을 하니까 절차지향적으로 나온다 이런 컨텍스트가 중요.
- 데이터와 프로세스를 완전히 분리하면 절차적인 결과물이 나올 수 있음.
- 무엇을 저장한 것인가를 생각
  - 그리고는 ERD 다이어그램을 그림
  - 근데 이것이 나쁜게 아니고, 데이터만 생각하는것이 좋지 않음
  - 데이터 모델과 동일한 모양의 클래스를 만듬. 1:1 로 속성을 매칭되게 해놓음
  - 그리고는 DAO 객체를 만들어 놓음
  - 기능을 생각하지 않고 일단, 데이터를 만들어놓음
  - 왜 getter setter를 열어 놓고 만들까? 어디서 어떻게 쓸줄 모르니까 일단, 다 열어놓고 본다.
- 타입체크를 한다? -> 절차 스멜
  - 스스로 어떤 타입인지, 어떤 역할을 하는 객체인지 판단할 수 있음
- 제어가 한군데에 모여있다는 특징이 있음.

## 객체지향 설계
- 프로세스와 데이터를 묶어 하나의 덩어리로 만듬 -> Object
- 어떤 컨텍스트가 있는 상황에서 어떤 클래스가 필요하지 라는 것을 생각을 함.
- 데이터와 프로세스 중에서 프로세스를 먼저 생각하고 데이터를 최대한 뒤로 미루어 생각함.
  - 프로세스를 만들면 데이터는 알아서 나중에 결정됨
- 메소드를 먼저 결정하고 그 다음에 속성을 결정
- 런타임 먼저 고민하고 컴파일을 생각해야한다.
- 객체를 설계하고 그 다음에 클래스화 한다.

- 영화에 대한 요구사항을 책임이라고 생각
- 책임을 담당할 수 있는 객체를 생각
- 객체의 책임 일부를 수행하기 위해 협력할 객체를 찾음
- 예매 생성을 할 책임을 가진 정보의 전문가에게 할당해준다.
  - 예매를 생성하는 정보를 가장 많이 가지고 있는 객체는 누구인가?
  - 적합한 객체를 찾는다.
- 예매를 하는데 가장 알만한 정보는?
- 상영은 무비, 할인정책, 할인 조건 등 예매에 필요한 많은 정보를 알고있음
- 그러니 상영에게 에매할 수 있는 책임을 할당한다.
- 예매를 하려면, 가격 계산을 해야하는데
- 계산의 책임을 누구에게 할당할 것인가?
  - 영화에게 할당
- 상영이 영화에게 가격을 계산해달라고 메시지를 요청하고 서로 협력하게 된다.


- 이런 작업들을 한 후 나중에 필드를 넣어준다.

- 의존성
  - 같은 라이프 사이클에서는 양방향으로 의존하고 있어도 괜찮다.
  - 왜냐? 같이 바뀔거라는 것을 가정하고 있으니까

- 의존성 느슨하게 하기
  - 객체로 묶어서 메시지 요청하기
  - 정말 필요한것만 추려서 메시지 요청하기
  - 이런 방법으로 양방향 -> 단방향으로 수정가능

# 왜 객체지향이 더 좋은가?

## 설계란?
- 코드를 배치하는 방식
- 내가 코드를 어떻게 배치하는 가?
- 요구사항이 복잡하지 않은데, 객체지향적으로 짠다고 인터페이스를 만들고 하는것이 좋지 않음.
- 좋은 설계란 변경하기 쉽게 코드를 배치하는 방식
- 동료가 읽기 쉽고 이해하기 쉽게 짜는 것
- 다양한 디자인패턴의 목적은 변경을 감추는 것이라고 보면 된다.
  - 전략패턴은 알고리즘의 변경을 감춰버리고 싶은 것

## 변경 관점에서 비교
### 응집도
- 내부 요소들이 함께 변경되는 것
- 자주 변경된다면 객체로 찢어내는 것이 좋다.
- 자주 변경되지 않는다면, 절차적으로 짜도 상관은 없다.

### 결합도 
구현과 추상화
- 자주변경되는 것이 구현
  - 자주 변경이 되니까 implements 하도록
- 자주변경되지 않는 것이 추상화
  - 자주 변경되지 않으니까 extends 하고 속성과 행위를 공유

### 캡슐화
- 변경될수 있는 부분을 감추놓는것
  - 변경이 일어나도 외부에 영향을 안주고 싶다.
- 타입을 캡슐화
  - 타입이 바뀌어도 다른 의존하는 곳에 변화를 주고 싶지 않다 -> 다형성
- 데이터 캡슐화
  - 데이터르 바꾸더라도 외부에 영향을 안주고 싶다.
- 구현을 재사용하고 싶어서 다형성을 쓰는경우는 아주 나쁘다.

### 요구사항 변경
#### 중복할인이 필요함
- 절차지향
  - 변경에 대한 개념이 추상화되어있지 않고 단편적인 코드로 남아있다.
- 객체지향
  - OverlappedDiscountPolicy 추가
  - 컴포지트 패턴 사용 - 사용 개수를 감춤
  - 확장을 했기때문에 Movie 에는 변화를 주지 않음.
  - OCP 만족

- 복잡하고 많이 변경하는 부분을 객체로 만들고, 나머지는 절차지향적으로 짜도 괜찮음.
- 중복이 무조건 나쁘다? 오히려 하나로 쓰게 만들려고 만든 슈퍼객체가 나쁠수 있음
- 변화에

# 코드의 품질을 어떻게 평가 하는가?
- 응집도
  - 어떤 관점으로 응집도를 바라 볼것인가?
- 결합도
  - 어떤 관점으로 결합도를 바라 볼것인가?
- 캡슐화
  - 어떤 관점으로 캡슐화를 바라 볼것인가?


# 추천도서
- applying uml
- gof 디자인패턴
- head first
- 패턴을 활용한 리팩터링책
- 로버트 마틴
  - 애자일 PPP
  - 솔리드 이야기